# WAS의 구조 및 서블릿 컨텍스트의 구조



### 요청 처리 및 WAS 내부 구조

![spring-architecture](https://user-images.githubusercontent.com/88477839/233042189-cfe6e905-72a5-4275-b4fb-0c6c3b37405e.png)

+ 그림 출처 - https://gowoonsori.com/spring/architecture/
+ 위 그림은 조금 잘못 되었으니 큰 흐름만 참고하자
  + 스프링 컨테이너가 톰캣(WAS) 바깥에 있는 것이 아니라 안에 있어야하고
  + 웹 어플리케이션(서블릿 컨텍스트) 안에 위치해야 한다.  



### 서블릿 컨테이너와 서블릿 컨텍스트

![다운로드 (4)](https://user-images.githubusercontent.com/88477839/233043773-b8ddb314-289a-451a-90ea-e3262ffa18e1.png)

+ 그림 출처 - https://java117.tistory.com/18
+ 컨테이너 실행 시 각 컨텍스트(웹 애플리케이션)마다 한 개의 서블릿 컨텍스트가 생성된다.
+ 서블릿 컨테이너의 역할
  + 웹서버와의 통신 지원
  + 서블릿 생명주기 관리
    + 서블릿 클래스를 로딩하여 인스턴스화
    + 초기화 메소드를 호출
    + 요청이 들어오면 적절한 서블릿 메소드를 호출
    + 서블릿 소멸 시 가비지 컬렉션 진행
  + 멀티쓰레드 지원 및 관리
    + 서블릿 컨테이너는 요청이 올 때 마다 새로운 자바 쓰데르를 하나 생성
    + http 서비스 메소드를 실행하고 나면, 쓰레드는 자동으로 소멸
  + 자료 출처 - https://cyk0825.tistory.com/78



### 서블릿 컨텍스트란

![images_ruinak_4127_post_42739c33-acc9-493d-bbbe-b3c60f0338d6_Screenshot_26](https://user-images.githubusercontent.com/88477839/233050266-e6ac7531-1a51-46f9-878e-fb28dc49fee0.png)

+ 사진 출처 https://velog.io/@ruinak_4127/Context
+ 서블릿 컨텍스트가 웹 애플리케이션을 감싸고 있다. 



### 서블릿 컨텍스트 객체란



![99ADAD4A5C733EB615](https://user-images.githubusercontent.com/88477839/233048029-adb0bc1c-4762-48bf-941b-2897d99f4dfc.png)

+ 사진 및 설명 출처 - https://kgvovc.tistory.com/38
+ 서블릿 컨텍스트 객체는 서블릿 컨테이너 안에 존재하며 서블릿 컨테이너와 통신하기 위해서 사용되는 메소드를 지원하는 인터페이스이다.
+ 서블릿 컨테이너가 시작 될 때 웹서버에 등록된 웹 애플리케이션 단위로 하나의 서블릿 컨텍스트 객체가 자동으로 생성된다.
+ 그리고 웹 어플리케이션 서비스가 중지될 때 서블릿 컨텍스트도 같이 소멸한다.
+ 즉 서블릿 컨텍스트 객체와 웹 애플리케이션의 생명주기는 같다.

#### WAS에 등록된 웹 애플리케이션 단위로 컨텍스트가 생성되는 이유는?

+ 서블릿 컨테이너가 웹 애플리케이션 단위로 모든 자원을 관리할 수 있게 하기 위해서이다.
+ 웹 애플리케이션 내에 있는 모든 서블릿, 그리고 JSP 간에 정보를 공유할 수 있고, 서블릿 컨테이너에 대한 정보를 추출할 수 있게 하는 기술이 바로 서블릿 컨텍스트이다.



### 스프링 컨테이너와 스프링 컨텍스트(또는 어플리케이션 컨텍스트)

![다운로드 (5)](https://user-images.githubusercontent.com/88477839/233053100-9893ee09-6c6b-4dec-a7fb-d99fb1879ad8.png)

+ 웹 어플리케이션 안에 스프링 컨테이너가 존재하며 스프링 컨테이너에는 여러개의 스프링 컨텍스트 (어플리케이션 컨텍스트)가 존재할 수 있다. 
+ 디스패처서블릿은 경우에 따라서 2개 이상 설정 할 수 있는데 이 경우 각각의 디스패처서블릿의 어플리케이션 컨텍스트가 독립적이기 때문에 서로의 설정 파일에서 생성한 빈을 서로 사용할 수 없다.
+ 위 경우와 별개로, 동시에 필요한 빈은 ContextLoaderListener를 활용하면 된다.
+ ContextLoaderListener와 DispathcerServlet은 각각 ApplicationContext를 생성하는데, ContextLoadeListener가 생성하는 ApplicationContext가 root컨텍스트가 되고 DispatcherServelt이 생성한 인스턴스는 root컨텍스트를 부모로 하는 자식 컨텍스트가 된다. 참고로, 자식 컨텍스트들은 root컨텍스트의 설정 빈을 사용할 수 있다.
+ **이렇게 ContextLoaderListener의 ApplicationContext(root-context.xml 설정 파일을 읽어 들임)와 DispathcerServlet의 ApplicatonContext(servlet-context.xml 설정 파일 읽어들임) 을 나누는 이유는 무엇일까?**
  + Root-context는 웹 기술에서 완전히 독립적인 비즈니스 서비스 계층과 데이터 액세스 계층을 담는다.
  + 반면 servlet-context는 스프링 웹 기술을 기반으로 동작하는 웹 관련 빈을 담는다.
  + 즉 컨텍스트를 두 가지로 분리함으로써 스프릉 웹 서블릿 컨텍스트를 통째로 다른 기술로 대체할 수 있도록 하기 위함이다.
  + 정보 출처 - https://drsggg.tistory.com/643



+ 웹 애플리케이션 컨텍스트란 스프링의 애플리케이션 컨텍스트를 확장한 인터페이스로, 웹 애플리케이션에서 필요한 몇 가지 기능을 추가한 인터페이스다.



### 정리

+ WAS(톰캣) 안에는 서블릿 컨테이너가 있다.
+ 서블릿 컨테이너 안에는 서블릿 컨텍스트 (웹 어플리케이션)가 있으며 여러개 존재 할 수 있다.
+ 서블릿 컨텍스트(웹 어플리케이션) 안에는 스프링 컨테이너가 있다.
+ 스프링 컨테이너 안에는 스프링 컨텍스트 (어플리케이션 컨텍스트)가 있으며 여러개 존재할 수 있다.
+ 어플리케이션 컨텍스트는 스프링 빈등을 관리한다.



+ 스프링 MVC 프로젝트를 생성할때 과정을 떠올려보면
  + 서블릿 컨테이너(톰캣)에 웹 애플리케이션(WAR)을 등록했다.
  + 웹 애플리케이션(WAR)에 DispatcherServlet을 등록했다.