# CS - 운영체제

### 참고 자료

+ https://velog.io/@codemcd/series/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-KOCW-%EC%96%91%ED%9D%AC%EC%9E%AC-%EA%B5%90%EC%88%98%EB%8B%98-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC
+ https://www.nossi.dev/interview/cs/os
+ https://gyoogle.dev/blog/computer-science/operating-system/Operation%20System.html



---

### 운영체제란?

+ 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어
+ 컴퓨터에서 실행한 응용 프로그램들을 관리하고 제어한다.
+ 운영체제의 가장 주된 목적은 컴퓨터의 하드웨어를 관리하는 것이다.
  + 컴퓨터에는 cpu, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크 등의 하드웨어가 있다.
  + 컴퓨터 하드웨어를 소프트웨어적으로 제어 및 관리한다.
+ 운영체제는 사용자에게 편의를 제공한다.
  + 운영체제가 없다면 컴퓨터의 하드웨어에 관한 모든 관리를 사용자가 직접해야하는 등 불편함을 겪게될 것이기 때문이다.



### 운영체제의 역할

1. 프로세스 관리
2. 저장장치 관리
3. 네트워킹
4. 사용자 관리
5. 디바이스 드라이버



+ #### 프로세스 관리

  + CPU를 점유해야 할 프로세스를 결정(스케줄링)
  + 결정한 프로세스에게 CPU 할당
  + 프로세스 간 공유 자원 접근과 통신 관리(IPC통신)
  + 동기화 관리

+ #### 저장장치 관리

  + 메인 메모리와 하드디스크 등을 관리하는 기능
  + 1차 저장장치(메인 메모리)
    + 프로세스에 할당하는 메모리 영역의 할당과 해제
    + 각 메모리 영역 간의 침범 방지
    + 가상 메모리 기능 (메인 메모리의 효율적 활용을 위함)
  + 2차 저장장치(하드디스크, NAND Flash Memory등)
    + 파일 형식의 데이터 저장
    + 파일 데이터 관리를 위한 파일 시스템을 OS에서 관리

+ #### 네트워킹

  + 운영체제에서 네트워크 프로토콜을 지원함
    + 때문에 TCP/IP기반에 인터넷에 연결 가능
    + 응용 프로그램이 네트워크를 사용할 수 있음

+ #### 사용자 관리

  + 운영체제는 한 컴퓨터를 여러 사람(여러 계정)이 사용하는 환경을 지원한다.
  + 따라서 운영체제는 각 계정을 관리할 수 있도록 파일이나 시스템 자원에 접근 권한을 지정할 수 있도록 지원한다.

+ #### 디바이스 드라이버

  + 운영체제에서는 하드웨어를 인식하고 관리하게 만들어 응용 프로그램이 하드웨어를 사용할 수 있게 만들어야 한다.
  + 따라서 운영체제 안에 하드웨어를 추상화 해주는 계층이 필요하고, 이 계층이 '디바이스 드라이버'이다.
    + 추상화란 중요한 특징을 찾아낸 후 간단하게 표현하는 것 
    + 또는 실재하는 객관적, 물적 대상을 재현하는 것이 아닌 비구상적이고 반사실주의적 경향의 미술을 의미
  + 하드웨어의 종류가 다양한 만큼 운영체제 내부의 디바이스 드라이버도 많이 존재한다.
  + 운영체제는 이러한 많은 디바이스 드라이버를 관리하는 기능을 가지고 있다. 



### 운영체제 구조

+ 운영체제는 커널과 명령어 해석기(Command interpreter, shell)로 나뉜다.
+ ![53879650-5b041180-4052-11e9-8950-ca9cca586d82](https://user-images.githubusercontent.com/88477839/229356110-aafcc6ab-b2d8-455e-ba5e-ea7530c80e45.png)
+ 커널은 운영체제의 핵심이다.
+ 명령어 해석기는 사용자가 커널에 요청하는 명령어를 해석하여 커널에 요청하고 그 결과를 출력한다.



### 운영체제와 사용자 어플리케이션

+ 어플리케이션은 운영체제 위에서 수행하며, 특정 운영체제에 맞춰서 제작된다.(운영체제가 다를시 어플리케이션 수행 안됨)
+ ![53879651-5b041180-4052-11e9-9b04-065091bd3199](https://user-images.githubusercontent.com/88477839/229356747-4f81c882-9bba-4461-bfc9-7ffd77887517.png)
+ 위 그림에서 어플리케이션은 운영체제를 통해서만 하드웨어 자원에 접근할 수 있다.
  + 운영체제는 어플리케이션과 하드웨어 사이에서 인터페이스 역할을 한다.
+ 즉 어플리케이션은 하드웨어 자원을 직접적으로 사용하지 않고 운영체제가 제공하는 자원만을 사용할 수 있다.



---

### Multiprogramming system (다중 프로그래밍)

+ idle 상태의 비율이 높은 단일 프로세스 시스템 문제를 해결하기 위해 다중 프로그래밍 시스템이 나왔다.
  + 프로그램을 수행하는 도중에는 계산을 하는 CPU(하드웨어)외에도 입출력을 담당하는 I/O장치(하드웨어)가 수행한다.
  + 즉 CPU와 I/O장치가 교대로 동작하게된다.
  + I/O장치가 수행하는 동안에는 CPU는 아무 할일이 없어지고 
  + CPU가 아무일도 안하는 상태를 idle 상태라고 한다.
  + I/O장치는 CPU에 비해 매우 느리기때문에 idle상태의 비율이 높아질 수 있다.
+ 다중 프로그래밍 시스템에서는 메모리에 여러 어플리케이션(프로그램)이 올라간다.
+ 따라서 a라는 프로그램에서 cpu수행을 하다가 I/O 장치 수행으로 넘어가도 
+ b라는 프로그램에서 CPU수행이 시작되기 때문에 idle 상태의 시간이 줄어들게 된다.
+ 멀티프로그래밍은 CPU 사용률을 극대화 시키는데 목적이 있다.
+ 하지만 이렇게 여러 프로그램이 메모리에 올라가면서 어떤 프로그램부터 CPU연산을 해줘야하는가 하는 문제가 생겨났는데 이러한 작업을 CPU 스케줄링이라고 한다.



---

### 멀티태스킹

+ 멀티프로그래밍은 한 프로세스에서 CPU 사용시간이 길어지면 다른 프로세스는 계속 대기한다는 단점이 있다.
+ 이 단점을 극복하기 위해 프로세스가 한번 CPU를 사용할 때 일정시간(시간을 잘게 쪼갠 매우 짧은시간 , quantum)만 CPU에서 실행되도록 하는 멀티 태스킹이 생겨남
  + a라는 프로세스에서 일정시간 cpu 연산이 일어남
  + 일정시간이 모두 소요되면(CPU 사용시간 만료) a 프로세스 연산을 중단하고 b 프로세스 넘어가 cpu연산을 다시 일정시간동안 진행
  + b 프로세스의 일정시간이 모두 소요되면(CPU 사용시간 만료) 다시 a 프로세스로 넘어감.
  + 위 과정을 거치며 여러개의 멀티 프로세스들이 동일한 짧은시간동안 번갈아 가면서 실행(CPU 연산)된다.
  + 일반적으로 멀티태스킹과 시분할 시스템은 같은 개념이라고 생각될정도로 굉장히 유사함 
    + 시분할 시스템은 타이머 인터럽트를 통해 구현된다.
+ 프로세스의 응답 시간을 최소화 시키는데 목적이 있으며
+ 때문에 동시에 여러 프로그램이 실행되고 있는 것 같은 느낌을 준다.
+ 예제
  + 싱글코어 CPU에  싱글-스레드 프로세스 두개



### 멀티태스킹의 단점

+ a라는 프로세스에서 b라는 프로세스로 CPU 점유가 넘어가며 '프로세스 컨텍스트 스위칭'이 일어난다.
+ 프로세스에서의 컨텍스트 스위칭은 오버헤드가 발생하는 무거운 작업이라는 단점이 있다.
+ 또한 프로세스는 독릭접인 메모리 공간을 가지고, 때문에 프로세스끼리 데이터 공유가 까다롭다. 



---

### 멀티 스레드

+ 위 멀티 태스킹의 단점을 보완하고자 멀티 스레드가 생겨남
  + 스레드는 프로세스의 실행 단위(CPU의 실행 단위)이자, 프로세스는 한 개 이상의 스레드를 가질 수 있다.
+ 스레드들끼리의 컨텍스트 스위칭은 프로세스들끼리의 컨텍스트 스위칭 보다 가볍다.
+ 스레드들은 stack 영역을 제외하고 자신들이 속한 프로세스의 메모리 영역을 공유한다.
  + 따라서 스레드들끼리 데이터 공유가 쉽다.
+ 멀티스레딩은 하나의 프로세스가 동시에 여러 작업을 실행하는데 목적이 있다.
+ 예제
  + 싱글코어 CPU에 듀얼-스레드 프로세스 한 개 ( 확장된 멀티 태스킹 개념이기도 함)

---

### 멀티프로세싱

+ 두 개 이상의 프로세서나 코어를 활용하는 시스템 
+ 예제
  + 듀얼코어 CPU에 싱글-스레드 프로세스 두 개 (멀티태스킹이 아님 -> 시분할 되지 않기 때문에)



---



### 컨텍스트 스위칭 (context switching)

+ CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것
  + 한 프로세스/스레드 에서 다른 프로세스/스레드로 CPU 제어권을 넘겨주는 것 
+ Context란 CPU가 해당 프로세스/스레드를 실행하기 위한 해당 프로세스/스레드의 정보/상태들을 의미한다.
  + CPU, 메모리 등등
+ 컨텍스트 스위칭은 여러 프로세스/ 스레드를 동시에 실행시키기 위해서 필요하다.



#### 컨텍스트 스위칭 발생 시점

+ 주어진 time slice(quantum)를 다 사용했거나 (CPU 사용 시간 만료)
+ IO 작업을 해야하거나 (I/O 인터럽트 )
  + I/O인터럽트가 발생하면 CPU는 다른 프로세스/스레드를 수행해야한다. (IDLE 상태 방지 위해)
+ 다른 리소스를 기다려야 하거나
+ 인터럽트 발생시 (인터럽트 처리를 기다릴때)



#### 컨텍스트 스위칭은 누구에 의해 실행되는가? (누구의 의해 발생되냐는 의미가 아님에 주의)

+ OS 커널 ( kernel)
  + 각종 리소스를 관리 / 감독하는 역할 
  + 컨텍스트 스위칭은 커널 모드에서 실행



### 컨텍스트 스위칭 실행 과정

+ a라는 프로세스/스레드 실행 (CPU 연산)
+ 타임 슬라이스 모두 소진 (CPU 사용 시간 만료) => 타이머 인터럽트 발생 (컨텍스트 스위칭 발생)
+ 커널 모드로 전환
+ 커널 모드에서 실행
+ CPU의 레지스터 상태를 교체 
  + a 프로세스/스레드의 상태정보(컨텍스트)를 PCB에 저장
  + CPU의 레지스터 상태를 b 프로세스/스레드의 상태정보로 교체 (PCB 에서 b의 컨텍스트를 불러와서)
  + (프로세스 컨텍스트 스위칭 일 시 주소 변환을 담당하는 MMU가 b 프로세스 주소를 바라보게 하고, 가상의 메모리 주소와 실제 물리적인 메모리 주소의 매핑 정보를 담고 있는 TLB를 비우는 과정을 추가로 진행 (스레드 컨텍스트 스위칭일시에는 하지 않는 과정)  )
+ 커널모드 종료 및 유저모드 전환
+ b 프로세스 / 스레드 실행 (CPU연산)
+ 위 과정 반복 



#### 컨텍스트 스위칭 실행과정 중 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭의 차이점

+ 스레드 컨텍스트 스위칭은 같은 프로세스 내의 메모리를 공유하기때문에 메모리에 관한 처리를 따로 해줄 필요 없다.
+ 그러나 프로세스 컨텍스트 스위칭은 컨텍스트간 메모리를 공유하지 않기 때문에 가상(virtual) 메모리 주소 관련 처리를 추가로 수행 해줘야 한다. (MMU와 TLB 관련)
+ 때문에 스레드 컨텐스트 스위칭이 더 빠르고 오버헤드가 발생하지 않는다.
  + 메모리 주소 관련 처리를 하지 않기 때문



#### 컨텍스트 스위칭이 미치는 간접적인 영향

+ 캐시(cache)를 오염시킨다.
  + CPU에는 캐시(cache) 라는 장소가 있다.
  + 이 캐시는 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소를 말한다.
  + 때문에 어떤 데이터가 필요할때 이미 이전에 사용했었던 데이터라면 굳이 메모리 영역까지 접근하지 않아도 된다는 이점이 있다. (때문에 속도가 빨라진다.)
  + 하지만 컨텍스트 스위칭이 자주 발생하면 이 캐시 안에 이전에 사용했었던 데이터들은 무용지물이 되고,
  + 데이터 사용시 매번 메모리 영역까지 접근해야하기때문에 속도가 느려진다.
  + 스레드간 컨텍스트 스위칭이 일어날때는 스레드 끼리는 같은 메모리를 공유하기 때문에 
  + 스레드가 바뀌어도 그나마 이전에 캐시에 복사된 데이터들을 활용할 여지가 남아있다.
+ 컨텍스트 스위칭이 자주 발생하면 오버헤드가 발생하고 때문에 컨텍스트 스위칭이 자주 발생하는 것은 좋지 않다.

---

### 인터럽트(Interrupt)

+ 시스템에서 발생한 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 매커니즘

+ 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것
  + 인터럽트 전기 신호가 발생하면 이를 CPU에게 보낸다.
  + CPU는 이를 감지하고, 자신이 하던 일을 멈춘 후(현재 실행중이던 명령어까지만 수행한다.) 커널 모드로 전환 
  + 현재의 프로그램 상태 보존을 위해 PC의 값을 스택에 저장한다. (인터럽트 종료 후 복귀 위해) 
  + 인터럽트 신호를 처리하기 위해 운영체제 내부에 있는 인터럽트를 처리하는 코드로 이동한다. (interrupt service routine, ISR)
  + ISR에는 해당 인터럽트가 발생했을때 어떻게 동작해야하는지가 내포 되어 있어 이를 수행한다.
  + 수행이 끝나면 인터럽트 발생 시 저장해둔 PC를 다시 복구하고
  + 이전에 수행중이던 원래 위치로 돌아가 프로그램을 재개한다.
  
+ 지금 수행 중인 일보다 더 중요한 일 (입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 한다.



### 인터럽트 종류

+ 외부 인터럽트 
  + CPU의 하드웨어 신호에 의해 발생
  + 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
+ 내부 인터럽트
  + CPU의 하드웨어 신호에 의해 발생
  + Trap이라고도 부름(또는 Exception)
  + 잘못된 명령이나 데이터를 사용할 때 발생
  + CPU가 어떤 명령을 수행할 수 없을때 자기 자신한테 인터럽트를 걸게 된다.
    + 이를 exception이라고 한다. (CPU가 처리 할 수 없는 예외상황이 발생함 )
  
+ 소프트웨어 인터럽트

  + 프로그램 처리 중 명령의 요청에 의해 발생한 것
  + 명령어로 직접 인터럽트 전기 신호를 CPU에게 보낼 수 있다.

  

#### 인터럽트 참고 자료

+ https://jhnyang.tistory.com/167



---

### 이중모드(Dual mode) - 유저모드와 커널모드

+ 컴퓨터 내에서는 여러 프로그램이 수행된다.
+ 이 때 특정 프로그램에서 잘못된 동작으로 인해 다른 프로그램이 영향을 받는다면 이는 매우 위험하다.
+ 이런 문제점을 해결하기 위해 일반 사용자가 치명적인 명령어를 요청하는 것을 막을 필요가 생겼고
+ 때문이 이중 모드가 나타나게 됐다.
+ 이중 모드는 CPU 내부의 레지스터의 비트를 활용하여 플래그(flag)로 나타낸다.
  + 예를 들어 커널 모드일때는 비트 값이 0이고 유저 모드 일때는 비트 값을 1로 설정하여 구분한다.
+ 이중 모드는 운영체제 기능 중에서 보호에 해당된다.
  + 운영체제에서 보호할 대상은 입출력 장치, 메모리, CPU 이다.
  + 운영체제의 경우, 시스템에 영향을 끼칠 수 있는 몇몇 명령어를 특권 명령으로 지정한다.
  + 만약 응용 프로그램이 해당 특권 명령을 시행하려고 접근한다면
  + OS측에서 잘못된 접근으로 인식하여 트랩(내부 인터럽트)를 걸어 프로그램을 중단시킨다.



#### 유저모드

+ 우리가 개발하는 프로그램 및 사용자 어플리케이션은 일반적으로 유저 모드에서 실행된다.

#### 커널모드

+ 커널이 구동되는 환경이며, 이 모드에서는 OS 시스템에 영향을 주는 명령어를 실행할 수 있다.
+ 시스템의 모든 메모리에 접근 할 수 있고 모든 CPU 명령을 실행 할 수 있다.
+ 커널 모드가 생겨난 이유는 시스템을 보호하기 위함이다. 



#### 듀얼 모드 실행 과정

+ 프로그램 실행 중에(유저 모드) 인터럽트가 발생하거나 시스템 콜을 호출하게 되면 실행을 중단하고 커널 모드로 전환
+ (커널 모드에서) 프로그램의 현재 CPU 상태를 저장한다.
+ (커널 모드에서) 커널이 인터럽트나 시스템 콜을 직접 처리 (CPU에서 커널 코드가 실행됨)
+ (커널 모드에서) 처리가 완료되면 중단됐던 프로그램의 CPU 상태를 복원 
+ 커널 모드에서 유저 모드로 전환되며 다시 통제권을 프로그램에게 반환 
+ (유저모드에서) 프로그램이 이어서 실행됨



#### 이중 모드 참고 자료

+ https://velog.io/@klm03025/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C
+ https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-3.-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8
+ https://jhnyang.tistory.com/190
+ https://www.youtube.com/watch?v=v30ilCpITnY&t=617s



---

### 시스템 콜

+ 프로그램이 OS 커널이 제공하는 서비스를 이용하고 실행하고 싶을 때 운영체제에 요청하는 호출이다.
+ 프로그램이 커널 모드에 접근할 수 없기 때문이다.
+ 시스템 콜은 인터럽트의 일종이다.(소프트웨어 인터럽트의 한 종류)
+ 시스템 콜의 종류
  + 프로세스 / 스레드 (생성하고, kill하고)
  + 파일 I/O 관련 (파일 읽고, 쓰고 )
  + 소켓 관련 (네트워크와 관련된 작업)
  + Device 관련
  + 프로세스 통신 관련 (프로세스들끼리 데이터를 주고받기)



---



### CPU bound와 IO bound

+ **CPU(central processing unit)** - 프로세스의 명령어를 해석하고 실행하는 장치
+ **IO(input/output)** 
  + 파일을 읽고 쓰거나 
  + 네트워크의 어딘가와 데이터를 주고 받는 것 
  + 입출력 장치(모니터, 마우스등)와 데이터를 주거나 받는 것 

+ **버스트(Burst)** - 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 일 
  + **CPU 버스트** - 프로세스가 CPU 에서 한번에 연속적으로 실행되는 시간 
  + **IO 버스트** - 프로세스가 IO 작업을 요청하고 결과를 기다리는 시간 
  + 프로세스의 인생은 CPU 버스트와 IO버스트이 연속이다. 



#### CPU bound 프로세스

+ CPU burst가 많은 프로세스 (계산/ 연산 작업이 많음)
+ CPU bound 프로세스 예
  +  동영상 편집 프로그램, 머신러닝 프로그램 
+ 듀얼 코어 CPU에서 동작할 CPU bound 프로그램을 구현한다면 코어 갯수 +1 정도의 스레드를 사용하는 것이 좋다. 
  + 어차피 CPU burst(CPU 연산이 많은)가 많은 프로그램이기 때문에
  + 컨텍스트 스위칭이 의미가 없고,
  + 스레드가 많아져서 컨텍스트 스위칭이 빈번해지면 오버헤드가 발생하고 성능이 떨어지기 때문에 
  + 코어 갯수와 비슷한 개수의 스레드만 사용하는 것이 좋다. 

#### IO bound 프로세스

+ IO burst가 많은 프로세스
+ IO bound 프로세스 예
  + (일반적인) 백엔드 API 서버 
    + IO의 역할 중 하나가 네트워크의 어딘가와 데이터를 주고 받는 것이기 때문에 
+ IO bound에서 스레드 갯수는 정해진게 없고, 여러 상황에 맞춰서 적절한 스레드 수를 찾아야 한다. 

