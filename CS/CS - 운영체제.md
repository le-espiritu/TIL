# CS - 운영체제

### 참고 자료

+ https://velog.io/@codemcd/series/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-KOCW-%EC%96%91%ED%9D%AC%EC%9E%AC-%EA%B5%90%EC%88%98%EB%8B%98-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC
+ https://www.nossi.dev/interview/cs/os
+ https://gyoogle.dev/blog/computer-science/operating-system/Operation%20System.html



---

### 운영체제란?

+ 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어
+ 컴퓨터에서 실행한 응용 프로그램들을 관리하고 제어한다.
+ 운영체제의 가장 주된 목적은 컴퓨터의 하드웨어를 관리하는 것이다.
  + 컴퓨터에는 cpu, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크 등의 하드웨어가 있다.
  + 컴퓨터 하드웨어를 소프트웨어적으로 제어 및 관리한다.
+ 운영체제는 사용자에게 편의를 제공한다.
  + 운영체제가 없다면 컴퓨터의 하드웨어에 관한 모든 관리를 사용자가 직접해야하는 등 불편함을 겪게될 것이기 때문이다.



### 운영체제의 역할

1. 프로세스 관리
2. 저장장치 관리
3. 네트워킹
4. 사용자 관리
5. 디바이스 드라이버



+ #### 프로세스 관리

  + CPU를 점유해야 할 프로세스를 결정(스케줄링)
  + 결정한 프로세스에게 CPU 할당
  + 프로세스 간 공유 자원 접근과 통신 관리(IPC통신)
  + 동기화 관리

+ #### 저장장치 관리

  + 메인 메모리와 하드디스크 등을 관리하는 기능
  + 1차 저장장치(메인 메모리)
    + 프로세스에 할당하는 메모리 영역의 할당과 해제
    + 각 메모리 영역 간의 침범 방지
    + 가상 메모리 기능 (메인 메모리의 효율적 활용을 위함)
  + 2차 저장장치(하드디스크, NAND Flash Memory등)
    + 파일 형식의 데이터 저장
    + 파일 데이터 관리를 위한 파일 시스템을 OS에서 관리

+ #### 네트워킹

  + 운영체제에서 네트워크 프로토콜을 지원함
    + 때문에 TCP/IP기반에 인터넷에 연결 가능
    + 응용 프로그램이 네트워크를 사용할 수 있음

+ #### 사용자 관리

  + 운영체제는 한 컴퓨터를 여러 사람(여러 계정)이 사용하는 환경을 지원한다.
  + 따라서 운영체제는 각 계정을 관리할 수 있도록 파일이나 시스템 자원에 접근 권한을 지정할 수 있도록 지원한다.

+ #### 디바이스 드라이버

  + 운영체제에서는 하드웨어를 인식하고 관리하게 만들어 응용 프로그램이 하드웨어를 사용할 수 있게 만들어야 한다.
  + 따라서 운영체제 안에 하드웨어를 추상화 해주는 계층이 필요하고, 이 계층이 '디바이스 드라이버'이다.
    + 추상화란 중요한 특징을 찾아낸 후 간단하게 표현하는 것 
    + 또는 실재하는 객관적, 물적 대상을 재현하는 것이 아닌 비구상적이고 반사실주의적 경향의 미술을 의미
  + 하드웨어의 종류가 다양한 만큼 운영체제 내부의 디바이스 드라이버도 많이 존재한다.
  + 운영체제는 이러한 많은 디바이스 드라이버를 관리하는 기능을 가지고 있다. 



### 운영체제 구조

+ 운영체제는 커널과 명령어 해석기(Command interpreter, shell)로 나뉜다.
+ ![53879650-5b041180-4052-11e9-8950-ca9cca586d82](https://user-images.githubusercontent.com/88477839/229356110-aafcc6ab-b2d8-455e-ba5e-ea7530c80e45.png)
+ 커널은 운영체제의 핵심이다.
+ 명령어 해석기는 사용자가 커널에 요청하는 명령어를 해석하여 커널에 요청하고 그 결과를 출력한다.



### 운영체제와 사용자 어플리케이션

+ 어플리케이션은 운영체제 위에서 수행하며, 특정 운영체제에 맞춰서 제작된다.(운영체제가 다를시 어플리케이션 수행 안됨)
+ ![53879651-5b041180-4052-11e9-9b04-065091bd3199](https://user-images.githubusercontent.com/88477839/229356747-4f81c882-9bba-4461-bfc9-7ffd77887517.png)
+ 위 그림에서 어플리케이션은 운영체제를 통해서만 하드웨어 자원에 접근할 수 있다.
  + 운영체제는 어플리케이션과 하드웨어 사이에서 인터페이스 역할을 한다.
+ 즉 어플리케이션은 하드웨어 자원을 직접적으로 사용하지 않고 운영체제가 제공하는 자원만을 사용할 수 있다.



---

### Multiprogramming system (다중 프로그래밍)

+ idle 상태의 비율이 높은 단일 프로세스 시스템 문제를 해결하기 위해 다중 프로그래밍 시스템이 나왔다.
  + 프로그램을 수행하는 도중에는 계산을 하는 CPU(하드웨어)외에도 입출력을 담당하는 I/O장치(하드웨어)가 수행한다.
  + 즉 CPU와 I/O장치가 교대로 동작하게된다.
  + I/O장치가 수행하는 동안에는 CPU는 아무 할일이 없어지고 
  + CPU가 아무일도 안하는 상태를 idle 상태라고 한다.
  + I/O장치는 CPU에 비해 매우 느리기때문에 idle상태의 비율이 높아질 수 있다.
+ 다중 프로그래밍 시스템에서는 메모리에 여러 어플리케이션(프로그램)이 올라간다.
+ 따라서 a라는 프로그램에서 cpu수행을 하다가 I/O 장치 수행으로 넘어가도 
+ b라는 프로그램에서 CPU수행이 시작되기 때문에 idle 상태의 시간이 줄어들게 된다.
+ 멀티프로그래밍은 CPU 사용률을 극대화 시키는데 목적이 있다.
+ 하지만 이렇게 여러 프로그램이 메모리에 올라가면서 어떤 프로그램부터 CPU연산을 해줘야하는가 하는 문제가 생겨났는데 이러한 작업을 CPU 스케줄링이라고 한다.



---

### 멀티태스킹

+ 멀티프로그래밍은 한 프로세스에서 CPU 사용시간이 길어지면 다른 프로세스는 계속 대기한다는 단점이 있다.
+ 이 단점을 극복하기 위해 프로세스가 한번 CPU를 사용할 때 일정시간(시간을 잘게 쪼갠 매우 짧은시간 , quantum)만 CPU에서 실행되도록 하는 멀티 태스킹이 생겨남
  + a라는 프로세스에서 일정시간 cpu 연산이 일어남
  + 일정시간이 모두 소요되면(CPU 사용시간 만료) a 프로세스 연산을 중단하고 b 프로세스 넘어가 cpu연산을 다시 일정시간동안 진행
  + b 프로세스의 일정시간이 모두 소요되면(CPU 사용시간 만료) 다시 a 프로세스로 넘어감.
  + 위 과정을 거치며 여러개의 멀티 프로세스들이 동일한 짧은시간동안 번갈아 가면서 실행(CPU 연산)된다.
  + 일반적으로 멀티태스킹과 시분할 시스템은 같은 개념이라고 생각될정도로 굉장히 유사함 
    + 시분할 시스템은 타이머 인터럽트를 통해 구현된다.
+ 프로세스의 응답 시간을 최소화 시키는데 목적이 있으며
+ 때문에 동시에 여러 프로그램이 실행되고 있는 것 같은 느낌을 준다.
+ 예제
  + 싱글코어 CPU에  싱글-스레드 프로세스 두개



### 멀티태스킹의 단점

+ a라는 프로세스에서 b라는 프로세스로 CPU 점유가 넘어가며 '프로세스 컨텍스트 스위칭'이 일어난다.
+ 프로세스에서의 컨텍스트 스위칭은 오버헤드가 발생하는 무거운 작업이라는 단점이 있다.
+ 또한 프로세스는 독릭접인 메모리 공간을 가지고, 때문에 프로세스끼리 데이터 공유가 까다롭다. 



---

### 멀티 스레드

+ 위 멀티 태스킹의 단점을 보완하고자 멀티 스레드가 생겨남
  + 스레드는 프로세스의 실행 단위(CPU의 실행 단위)이자, 프로세스는 한 개 이상의 스레드를 가질 수 있다.
+ 스레드들끼리의 컨텍스트 스위칭은 프로세스들끼리의 컨텍스트 스위칭 보다 가볍다.
+ 스레드들은 stack 영역을 제외하고 자신들이 속한 프로세스의 메모리 영역을 공유한다.
  + 따라서 스레드들끼리 데이터 공유가 쉽다.
+ 멀티스레딩은 하나의 프로세스가 동시에 여러 작업을 실행하는데 목적이 있다.
+ 예제
  + 싱글코어 CPU에 듀얼-스레드 프로세스 한 개 ( 확장된 멀티 태스킹 개념이기도 함)

---

### 멀티프로세싱

+ 두 개 이상의 프로세서나 코어를 활용하는 시스템 
+ 예제
  + 듀얼코어 CPU에 싱글-스레드 프로세스 두 개 (멀티태스킹이 아님 -> 시분할 되지 않기 때문에)



---



### 컨텍스트 스위칭 (context switching)

+ CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것
  + 한 프로세스/스레드 에서 다른 프로세스/스레드로 CPU 제어권을 넘겨주는 것 
+ Context란 CPU가 해당 프로세스/스레드를 실행하기 위한 해당 프로세스/스레드의 정보/상태들을 의미한다.
  + CPU, 메모리 등등
+ 컨텍스트 스위칭은 여러 프로세스/ 스레드를 동시에 실행시키기 위해서 필요하다.



#### 컨텍스트 스위칭 발생 시점

+ 주어진 time slice(quantum)를 다 사용했거나 (CPU 사용 시간 만료)
+ IO 작업을 해야하거나 (I/O 인터럽트 )
  + I/O인터럽트가 발생하면 CPU는 다른 프로세스/스레드를 수행해야한다. (IDLE 상태 방지 위해)
+ 다른 리소스를 기다려야 하거나
+ 인터럽트 발생시 (인터럽트 처리를 기다릴때)



#### 컨텍스트 스위칭은 누구에 의해 실행되는가? (누구의 의해 발생되냐는 의미가 아님에 주의)

+ OS 커널 ( kernel)
  + 각종 리소스를 관리 / 감독하는 역할 
  + 컨텍스트 스위칭은 커널 모드에서 실행



### 컨텍스트 스위칭 실행 과정

+ a라는 프로세스/스레드 실행 (CPU 연산)
+ 타임 슬라이스 모두 소진 (CPU 사용 시간 만료) => 타이머 인터럽트 발생 (컨텍스트 스위칭 발생)
+ 커널 모드로 전환
+ 커널 모드에서 실행
+ CPU의 레지스터 상태를 교체 
  + a 프로세스/스레드의 상태정보(컨텍스트)를 PCB에 저장
  + CPU의 레지스터 상태를 b 프로세스/스레드의 상태정보로 교체 (PCB 에서 b의 컨텍스트를 불러와서)
  + (프로세스 컨텍스트 스위칭 일 시 주소 변환을 담당하는 MMU가 b 프로세스 주소를 바라보게 하고, 가상의 메모리 주소와 실제 물리적인 메모리 주소의 매핑 정보를 담고 있는 TLB를 비우는 과정을 추가로 진행 (스레드 컨텍스트 스위칭일시에는 하지 않는 과정)  )
+ 커널모드 종료 및 유저모드 전환
+ b 프로세스 / 스레드 실행 (CPU연산)
+ 위 과정 반복 



#### 컨텍스트 스위칭 실행과정 중 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭의 차이점

+ 스레드 컨텍스트 스위칭은 같은 프로세스 내의 메모리를 공유하기때문에 메모리에 관한 처리를 따로 해줄 필요 없다.
+ 그러나 프로세스 컨텍스트 스위칭은 컨텍스트간 메모리를 공유하지 않기 때문에 가상(virtual) 메모리 주소 관련 처리를 추가로 수행 해줘야 한다. (MMU와 TLB 관련)
+ 때문에 스레드 컨텐스트 스위칭이 더 빠르고 오버헤드가 발생하지 않는다.
  + 메모리 주소 관련 처리를 하지 않기 때문



#### 컨텍스트 스위칭이 미치는 간접적인 영향

+ 캐시(cache)를 오염시킨다.
  + CPU에는 캐시(cache) 라는 장소가 있다.
  + 이 캐시는 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소를 말한다.
  + 때문에 어떤 데이터가 필요할때 이미 이전에 사용했었던 데이터라면 굳이 메모리 영역까지 접근하지 않아도 된다는 이점이 있다. (때문에 속도가 빨라진다.)
  + 하지만 컨텍스트 스위칭이 자주 발생하면 이 캐시 안에 이전에 사용했었던 데이터들은 무용지물이 되고,
  + 데이터 사용시 매번 메모리 영역까지 접근해야하기때문에 속도가 느려진다.
  + 스레드간 컨텍스트 스위칭이 일어날때는 스레드 끼리는 같은 메모리를 공유하기 때문에 
  + 스레드가 바뀌어도 그나마 이전에 캐시에 복사된 데이터들을 활용할 여지가 남아있다.
+ 컨텍스트 스위칭이 자주 발생하면 오버헤드가 발생하고 때문에 컨텍스트 스위칭이 자주 발생하는 것은 좋지 않다.



---



### race condition ( 경쟁 조건 )

+ 여러 프로세스 / 스레드가 동시에 같은 데이터를 조작할 때 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황



### 동기화 (synchronization)

+ 여러 프로세스 / 스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것

+ 그렇다면 동기화는 어떻게 해야할까? 임계영역을 설정하고 다양한 동기화 기법을 활용한다.

  

### critical section (임계 영역)

+ 위에서 서술한 동기화를 진행하기 위해서는 임계 영역을 설정하고 동기화 기법을 사용해야 한다.
+ 임계 영역이란 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행 가능한 영역을 말한다.



### critical section problem의 해결책이 되기 위한 조건

1. mutual exclusion (상호 배제)
   + 한번에 하나의 프로세스 / 스레드만 임계영역에서 실행 할 수 있다는 의미
2. progress(진행)
   + 만약 임계영역이 비워져 있고 어떤 프로세스/스레드 들이 이 임계영역에 들어가길 원한다면 그 중에 하나는 임계영역에서 실행될 수 있도록 해야 한다는 의미 
   + 진행이 계속 될 수 있어야 한다는 의미
3. bounded waiting (한정된 대기)
   + 어떤 프로세스 / 스레드가 무한정 임계영역에 들어가지 못하고 기다리고 있으면 안된다는 의미 



#### * 프로그래밍 할때 Thread-safe 한지 확인해야 한다.

+ 자바 자료구조에서 Hashtable은 쓰레드 세이프하지만, Hash map은 쓰레드 세이프 하지 않다.
+ 자바 자료구조에서 벡터는 쓰레드 세이프 하지만 arrayList는 쓰레드 세이프 하지 않다. 



---



### 동기화(synchronization) 기법



#### 임계영역의 mutual exclusion(상호 배제)는 어떻게 보장 할 수 있을가?

+ 락(lock)을 사용한다. 



#### 스핀락(spinlock)

+ 락을 가질 수 있을 때 까지 반복해서 시도 
+ 하지만 락을 기다리는 동안 CPU를 낭비한다는 단점이 있다.

+ 멀티 코어 환경이고, critical section에서의 작업이 컨텍스트 스위칭보다 더 빨리 끝난다면 스핀락이 뮤텍스보다 더 이점이 있다.



#### 뮤텍스(mutex)

+ 락을 가질 수 있을 때 까지 휴식
+ 휴식을 깨우는 과정에서 컨텍스트 스위칭 발생 



#### semaphore(세마포어)

+ signal mechanisam을 가진, 하나 이상의 프로세스/스레드가 critical section에 접근 가능하도록 하는 장치
+ 뮤텍스의 lock이 세마포어에서는 wait / 뮤텍스의 unlock이 세마포어에서는 signal 
+ 세마포어는 signal mechanism으로 인해 순서를 정해줄 때도 사용한다 



#### 모니터(monitor)

	+ mutual exclusion을 보장
	+ 조건에 따라 스레드가 대기(waiting)상태로 전환 가능
	+ 모니터는 한번에 하나의 스레드만 실행돼야 할때 사용되고,
	+ 여러 스레드와 협업(cooperation)이 필요할 때 사용된다. 
 + 모니터는 mutex와 condition variable(s)로 이루어져 있다.
   + mutex
     + mutex는 ciritical section에서 mutual exclusion을 보장하는 장치이다.
     + critical section에 진입하려면 mutex lock을 취득해야 한다.
     + mutex lock을 취득하지 못한 스레드는 큐에 들어간 후 대기(waiting ) 상태로 전환된다. 
     + Mutex lock을 쥔 스레드가 lock을 반환하면, 락을 기다리며 큐에 대기 상태로 있던 스레드 중 하나가 실행된다.  
   + condition variable
     + waiting queue를 가진다. ( waiting queue는 조건이 충족되길 기다리는 스레드들이 대기 상태로 머무는 곳이다.)
   + condition variable에서의 주요 동작(operation)
     + Wait - thread가 자기 자신을 condition variable의 waiting queue에 넣고 대기 상태로 전환 (자신이 기대한 어떤 조건이 아직 충족되지 않았을때 wait를 호출, 이 때 자신이 가진 뮤텍스 락을 반환한다. (자신이 대기하는 동안 다른 프로세스가 임계영역에 진입할 수 있도록 하기 위함.))
     + signal - waiting queue에서 대기중인 스레드 중 하나를 깨움 
     + Broadcast - waiting queue에서 대기중인 스레드 전부를 깨움 
   + 모니터에는 두 개의 큐가 존재한다.
     + Entry queue : ciritical section에 진입을 기다리는 큐 (뮤텍스에서 관리)
     + waiting queue : 조건이 충족되길 기다리는 큐 (condition variable에서 관리)
 + 자바에서 모니터 
   + 자바에서 모든 객체는 내부적으로 모니터를 가진다. 
   + 모니터의 mutual exclusion 기능은 synchronized 키워드로 사용한다.
   + 자바의 모니터는 condition variable를 하나만 가진다. 
   + 자바 모니터의 세 가지 동작
     + wait
     + notify
     + notifyAll 



### 뮤텍스와 세마포어의 차이점

	+ 뮤텍스는 락을 가진 자만 락을 해제할 수 있지만 세마포어는 그렇지 않다. 
 + 뮤텍스는 priority inheritance속성을 가진다.
   + 세마포어는 그 속성이 없다.  



---

### Deadlock(교착상태)

#### deadlock이란?

+ 두개 이상의 프로세스 혹은 스레드가 리소스를 점유한 상태에서 서로가 가진 리소스를 기다리는 상태



#### 데드락을 만드는 네 가지 조건

+ mutual exclusion : 상호 배제 / 한번에 하나의 프로세스(또는 스레드)만 리소스를 사용할 수 있다.
+ Hold and wait(점유 대기) : 프로세스가 이미 하나 이상의 리소스를 취득한(hold) 상태에서 다른 프로세스가 사용하고 있는 리소스를 추가로 기다린다.(wait)
+ No preemption(비선점) : 리소스 반환은 오직 그 리소스를 취득한 프로세스만 할 수 있다. (다른 프로세스가 점유한 리소스를 강제로 선점할 수 없다.)
+ Circular wait (순환대기) : 프로세스들이 순환(circular) 형태로 서로의 리소스를 기다린다.  



#### OS의 데드락 해결 방법

+ 데드락 방지
  1. 데드락을 만드는 네 가지 조건 중 하나가 충족되지 않게 시스템을 디자인

     + mutual exclusion -> 리소스를 공유 가능하게 변경 (현실적으로 불가능)
     + Hold and wait 조건을 충족시키지 않는 경우 
       + 사용할 리소스들을 모두 획득한 뒤에 시작
       + 혹은 리소스를 전혀 가지지 않은 상태에서만 리소스 요청할 수 있도록 함
     + No preemption(비선점)을 충족시키지 않는 경우
       + 추가적인 리소스를 기다려야 한다면 이미 획득한 리소스를 다른 프로세스가 선점 가능하도록 한다.
       + 시분할 시스템과 유사 (타임 슬라이스를 다 사용하면 다른 프로세스에게 cpu 양보)

     + circular wait(순환대기)를 충족시키지 않는 경우
       + 모든 리소스에 순서 체계를 부여해서 오름차순으로 리소스를 요청
         + 즉 자신이 점유한 리소스보다 순서 숫자가 더 큰 리소스만 확보할 수 있도록 하는 것
         + 이렇게 되면 가장 순서 숫자가 큰 리소스는 다음 리소스를 확보할 수 없기 때문에 순환 형태가 깨지게 된다.
         + 리소스가 여러개 필요한 경우 순서 숫자가 작은 리소스를 먼저 확보하고 그 다음 순서를 확보하게 한다.

+ 데드락 회피

   + 실행 환경에서 추가적인 정보(현재 사용 가능한 리소스들, 이미 누군가에게 할당된 리소스들, 미래에 있을 리소스 요청이나 반환등에 관한 정보)를 활용해서 데드락이 발생할 것 같은 상황을 회피하는 것 
   + banker altorithm
     + 리소스 요청을 허락해줬을 때 데드락이 발생할 가능성이 있으면 리소스를 할당해도 안전할 때 까지 계속 요청을 거절하는 알고리즘 
+ 데드락 감지와 복구

   + 데드락을 허용하고 데드락이 발생하면 복구하는 전략 
     + 프로세스를 종료하는 방법
     + 리소스의 일시적인 선점을 허용한다. 
+ 데드락 무시 

​	

---

### OS 프로세스 상태

#### 프로세스의 상태

+ new : 프로세스가 새로 생성됨 
+ ready : 프로세스가 cpu에서 실행되기 위해 기다리는 상태 
+ running : cpu를 할당받아 실행되는 상태
  + 시분할 시스템(멀티태스킹)에서 자신에게 할당된 타임 슬라이스를 모두  소진하게 되면 다시 ready 상태로 돌아감 
+ waiting : I/O 작업이 발생했거나 critical section에 진입하지 못해 대기하는 상태
  + I/O작업이 모두 완료 됐거나 critical section에 진입할 수 있게 되면 ready상태로 바뀐다. 
  + cpu에서 다른 작업을 하고 있을 수도 있기 때문에 바로 running으로 바뀌지 않고 ready로 바뀐다. 
+ Terminated : 프로세스가 종료됨 



---

### CPU scheduler와 dispatcher

#### CPU scheduler

+ 어떤 프로세스에게 cpu를 할당할지 선택하는 역할을 함 
+ ready상태의 프로세스 들이 모여있는 큐를 ready 큐라고 하는데 cpu 스케줄러는 이 ready큐에서 어떤 프로세스에게 cpu를 할당할지 선택하는 역할을 한다. 



#### dispatcher

+ 선택된 프로세스에게 CPU를 할당하는 역할
+ dispatcher가 context switching을 수행한다.



---

### 스케줄링의 선점 방식

#### Nonpreemptive(비선점) scheduling

+ 어떤 프로세스가 cpu를 모두 사용할때까지 기다려줌 
+ 신사적, 협력적(cooperative), 느린 응답성 



#### Preemptive(선점) scheduling

+ 프로세스가 cpu에서 실행이 다 끝나지 않았음에도 운영체제에서 개입해서 상태를 ready로 만드는 경우 
  + 예를 들어 시분할 시스템(멀티 태스킹) : 타임 슬라이스를 모두 소진하면 ready 상태로 변경
+ 적극적, 강제적, 빠른 응답성, 데이터 일관성 문제 



---

### 스케줄링 알고리즘

#### FCFS(first-come, first-served)

+ ready큐에 먼저 도착한 프로세스 순서대로 처리 

#### SJF(shortest-job-first)

+ 프로세스의 다음 CPU burst가 가장 짧은 프로세스부터 실행 

#### SRTF(shortest-remaining-time-first)

+ 남은 CPU busrt가 가장 짧은 프로세스부터 실행 
+ SJF에서 선점 방식이 적용된 것이 SRTF이다. 

#### Priority

+ 우선순위가 높은 프로세스부터 실행

#### RR(round-robin)

+ time slice로 나눠진 CPU time을 번갈아가며 실행 

#### Multilevel queue

+ 프로세스들을 그룹화해서 그룹마다 큐를 두는 방식 



---

### 인터럽트(Interrupt)

+ 시스템에서 발생한 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 매커니즘

+ 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것
  + 인터럽트 전기 신호가 발생하면 이를 CPU에게 보낸다.
  + CPU는 이를 감지하고, 자신이 하던 일을 멈춘 후(현재 실행중이던 명령어까지만 수행한다.) 커널 모드로 전환 
  + 현재의 프로그램 상태 보존을 위해 PC의 값을 스택에 저장한다. (인터럽트 종료 후 복귀 위해) 
  + 인터럽트 신호를 처리하기 위해 운영체제 내부에 있는 인터럽트를 처리하는 코드로 이동한다. (interrupt service routine, ISR)
  + ISR에는 해당 인터럽트가 발생했을때 어떻게 동작해야하는지가 내포 되어 있어 이를 수행한다.
  + 수행이 끝나면 인터럽트 발생 시 저장해둔 PC를 다시 복구하고
  + 이전에 수행중이던 원래 위치로 돌아가 프로그램을 재개한다.
  
+ 지금 수행 중인 일보다 더 중요한 일 (입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 한다.



### 인터럽트 종류

+ 외부 인터럽트 
  + CPU의 하드웨어 신호에 의해 발생
  + 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
+ 내부 인터럽트
  + CPU의 하드웨어 신호에 의해 발생
  + Trap이라고도 부름(또는 Exception)
  + 잘못된 명령이나 데이터를 사용할 때 발생
  + CPU가 어떤 명령을 수행할 수 없을때 자기 자신한테 인터럽트를 걸게 된다.
    + 이를 exception이라고 한다. (CPU가 처리 할 수 없는 예외상황이 발생함 )
  
+ 소프트웨어 인터럽트

  + 프로그램 처리 중 명령의 요청에 의해 발생한 것
  + 명령어로 직접 인터럽트 전기 신호를 CPU에게 보낼 수 있다.

  

#### 인터럽트 참고 자료

+ https://jhnyang.tistory.com/167



---

### 이중모드(Dual mode) - 유저모드와 커널모드

+ 컴퓨터 내에서는 여러 프로그램이 수행된다.
+ 이 때 특정 프로그램에서 잘못된 동작으로 인해 다른 프로그램이 영향을 받는다면 이는 매우 위험하다.
+ 이런 문제점을 해결하기 위해 일반 사용자가 치명적인 명령어를 요청하는 것을 막을 필요가 생겼고
+ 때문이 이중 모드가 나타나게 됐다.
+ 이중 모드는 CPU 내부의 레지스터의 비트를 활용하여 플래그(flag)로 나타낸다.
  + 예를 들어 커널 모드일때는 비트 값이 0이고 유저 모드 일때는 비트 값을 1로 설정하여 구분한다.
+ 이중 모드는 운영체제 기능 중에서 보호에 해당된다.
  + 운영체제에서 보호할 대상은 입출력 장치, 메모리, CPU 이다.
  + 운영체제의 경우, 시스템에 영향을 끼칠 수 있는 몇몇 명령어를 특권 명령으로 지정한다.
  + 만약 응용 프로그램이 해당 특권 명령을 시행하려고 접근한다면
  + OS측에서 잘못된 접근으로 인식하여 트랩(내부 인터럽트)를 걸어 프로그램을 중단시킨다.



#### 유저모드

+ 우리가 개발하는 프로그램 및 사용자 어플리케이션은 일반적으로 유저 모드에서 실행된다.

#### 커널모드

+ 커널이 구동되는 환경이며, 이 모드에서는 OS 시스템에 영향을 주는 명령어를 실행할 수 있다.
+ 시스템의 모든 메모리에 접근 할 수 있고 모든 CPU 명령을 실행 할 수 있다.
+ 커널 모드가 생겨난 이유는 시스템을 보호하기 위함이다. 



#### 듀얼 모드 실행 과정

+ 프로그램 실행 중에(유저 모드) 인터럽트가 발생하거나 시스템 콜을 호출하게 되면 실행을 중단하고 커널 모드로 전환
+ (커널 모드에서) 프로그램의 현재 CPU 상태를 저장한다.
+ (커널 모드에서) 커널이 인터럽트나 시스템 콜을 직접 처리 (CPU에서 커널 코드가 실행됨)
+ (커널 모드에서) 처리가 완료되면 중단됐던 프로그램의 CPU 상태를 복원 
+ 커널 모드에서 유저 모드로 전환되며 다시 통제권을 프로그램에게 반환 
+ (유저모드에서) 프로그램이 이어서 실행됨



#### 이중 모드 참고 자료

+ https://velog.io/@klm03025/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C
+ https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-3.-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8
+ https://jhnyang.tistory.com/190
+ https://www.youtube.com/watch?v=v30ilCpITnY&t=617s



---

### 시스템 콜

+ 프로그램이 OS 커널이 제공하는 서비스를 이용하고 실행하고 싶을 때 운영체제에 요청하는 호출이다.
+ 프로그램이 커널 모드에 접근할 수 없기 때문이다.
+ 시스템 콜은 인터럽트의 일종이다.(소프트웨어 인터럽트의 한 종류)
+ 시스템 콜의 종류
  + 프로세스 / 스레드 (생성하고, kill하고)
  + 파일 I/O 관련 (파일 읽고, 쓰고 )
  + 소켓 관련 (네트워크와 관련된 작업)
  + Device 관련
  + 프로세스 통신 관련 (프로세스들끼리 데이터를 주고받기)



---



### CPU bound와 IO bound

+ **CPU(central processing unit)** - 프로세스의 명령어를 해석하고 실행하는 장치
+ **IO(input/output)** 
  + 파일을 읽고 쓰거나 
  + 네트워크의 어딘가와 데이터를 주고 받는 것 
  + 입출력 장치(모니터, 마우스등)와 데이터를 주거나 받는 것 

+ **버스트(Burst)** - 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 일 
  + **CPU 버스트** - 프로세스가 CPU 에서 한번에 연속적으로 실행되는 시간 
  + **IO 버스트** - 프로세스가 IO 작업을 요청하고 결과를 기다리는 시간 
  + 프로세스의 인생은 CPU 버스트와 IO버스트이 연속이다. 



#### CPU bound 프로세스

+ CPU burst가 많은 프로세스 (계산/ 연산 작업이 많음)
+ CPU bound 프로세스 예
  +  동영상 편집 프로그램, 머신러닝 프로그램 
+ 듀얼 코어 CPU에서 동작할 CPU bound 프로그램을 구현한다면 코어 갯수 +1 정도의 스레드를 사용하는 것이 좋다. 
  + 어차피 CPU burst(CPU 연산이 많은)가 많은 프로그램이기 때문에
  + 컨텍스트 스위칭이 의미가 없고,
  + 스레드가 많아져서 컨텍스트 스위칭이 빈번해지면 오버헤드가 발생하고 성능이 떨어지기 때문에 
  + 코어 갯수와 비슷한 개수의 스레드만 사용하는 것이 좋다. 

#### IO bound 프로세스

+ IO burst가 많은 프로세스
+ IO bound 프로세스 예
  + (일반적인) 백엔드 API 서버 
    + IO의 역할 중 하나가 네트워크의 어딘가와 데이터를 주고 받는 것이기 때문에 
+ IO bound에서 스레드 갯수는 정해진게 없고, 여러 상황에 맞춰서 적절한 스레드 수를 찾아야 한다. 



---

### 스레드 종류

#### Hardware thread

+ 코어(core)의 고민 - 코어에서 진행하는 연산작업에 비해 메모리에서 데이터를 기다리는 시간이 꽤 오래 걸린다.
+ 그래서 메모리를 기다리는 동안 코어를 낭비하지 않기 위해 다른 스레드를 실행한다. 
+ 이렇게 연산을 하다가 메모리와 관련된 작업을 하는 동안에는 코어에서 연산을 진행하는 또다른 스레드를 실행한다.
+ 이때 이 각각의 스레드가 하드웨어 스레드이다. 
+ 그래서 물리적인 코어마다 하드웨어 스레드가 두개 존재하게 된다.
+ 즉 하드웨어 스레드는 OS관점에서 가상의(logical) 코어이다.
+ 만약에 싱글 코어 cpu에 하드웨어 스레드가 두개라면 OS는 이 CPU를 듀얼 코어로 인식하고 듀얼 코어에 맞춰서 OS레벨의 스레드들을 스케줄링 한다. 



#### OS thread

+ OS 커널 레벨에서 생성되고 관리되는 스레드 
+ OS 스레드는 CPU에서 실제로 실행되는 단위, CPU 스케줄링의 단위이다.
+ OS스레드의 컨텍스트 스위칭은 커널이 개입 -> 비용 발생한다.
+ 사용자 코드와 커널 코드 모두 OS 스레드에서 실행된다.
+ 네이티브 스레드, 커널 스레드, 커널-레벨 스레드, OS-레벨 스레드 등으로 불리기도 함 

+ kernel thread는 os커널의 역할을 수행하는 스레드를 의미하기도 한다. 

#### user thread

+ 유저 스레드는 유저-레벨 스레드라고 불리기도 한다.
+ 유저 스레드는 스레드 개념을 프로그래밍 레벨에서 추상화 한 것이다. 
  + Thread thread = new Thread();
  + thread.start();
+ 유저 스레드가 CPU에서 실행되려면 OS스레드와 반드시 연결돼야 한다.



#### 유저 스레드와 os스레드를 어떻게 연결시킬 것인가?

+ One-to-One model
  + 유저스레드와 os스레드가 1:1 매핑이 되는 것
  + 스레드 관리를 OS에 위임한다.
  + 스케줄링을 커널이 수행함
  + 멀티코어도 잘 활용함
  + 한 스레드가 블락이 되도 다른 스레드는 잘 동작한다.
  + race condition이 발생할 수도 있다.
+ Many-to-One model
  + 한개의 OS스레드에 여러개의 유저 스레드가 매핑되는 경우 
  + 유저 스레드간의 컨텍스트 스위칭이 빠르다는 특징이 있다.
  + OS스레드는 한개이기 때문에 race condition이 일어날 가능성이 적다.
  + 하지만 역시 OS스레드가 한개이기 때문에 멀티코어를 활용하지 못한다.
  + 한 유저 스레드가 블락이 되면 나머지 다른 모든 유저 스레드들도 블락이 된다.
+ Many-to-many model
  + Ont-to-one과 many-to-one의 장점을 합친 모델
  + 구현이 어렵다는 특징이 있다. 



---



### 스레드 풀 (thread pool)



#### Thread per request model

+ 서버 API에 요청에 들어오면 처리하는 방식 중 하나
+ 들어오는 리퀘스트(요청) 마다 쓰레드를 생성해서 하나의 요청에는 하나의 스레드가 처리할 수 있도록 1:1 매핑을 하는 것
+ 서버에 들어오는 요청마다 스레드를 새로 만들어서 처리함



#### Thread per request model의 문제점

+ 스레드 생성에는 시간이 소요되기 때문에 요청 처리가 더 오래 걸린다.
+ 처리 속도보다 더 빠르게 요청이 늘어나면
  + 스레드가 계속 생성 -> 스레드 수 증가 -> 메모리가 점점 더 고갈됨
  + 컨텍스트 스위칭이 더 자주 발생 (스레드가 많아져서)
  + CPU 오버헤드 증가로 CPU time 낭비
  + -> 어느 순간 서버 전체가 응답 불가능 상태에 빠짐



#### 스레드 풀이란?

+ 미리 스레드를 여러개 만들어 놓고 재사용 하는 것 
  + => 스레드 생성 시간이 절약된다. 
+ 제한된 개수의 스레드를 운용
  + => 때문에 스레드가 무제한으로 생성되는 것을 방지한다.



#### 스레드 풀 동작 과정

+ 스레드 풀 안에는 요청을 차례로 처리하기 위해 보관하는 요청 큐가 있다.
  + 요청이 들어오면 요청들은 우선적으로 큐에 차례로 보관이 된다.
+ 스레드 풀안에 미리 만들어 놓은 스레드중 일이 없는 스레드에게 큐에 있는 요청들을 차례로 할당하여 처리한다. 
+ 처리가 완료되면 스레드는 버려지지 않고 스레드 풀로 다시 돌아온다. 



#### 스레드 풀의 사례

+ 여러 작업을 동시에 처리해야할 때 활용된다.
  + thread per request 모델
  + task를 subtask로 나뉘어서 동시에 처리
  + 순서 상관없이 동시 실행이 가능한 task 처리



#### 스레드 풀에는 몇 개의 스레드를 만들어 두는게 적절한가?

+ CPU의 코어 개수와 task의 성향에 따라 다르다.
  + CPU-bound task : 코어 개수 만큼이나 그 보다 몇개 더 많은 정도
  + I/O-bound task : 경험적으로 찾아야 함

#### 스레드 풀에서 실행될 task 개수에 제한이 없다면

 + 스레드 풀의 큐 사이즈가 제한이 있는지 꼭 확인해야 한다. 
   + 요청 수에는 제한이 없어서 요청이 굉장히 많이 들어올 시 스레드 풀 내부 큐에는 요청들이 굉장히 많이 쌓이게 된다.
   + 이는 메모리를 고갈 시키는 위험 요인이 될 수 있다. 
   + 때문에 스레드 풀 내부 큐 사이즈에 제한을 둬야 한다. (그 이후 요청들을 버릴지라도 전체 시스템에 문제가 생기지 않게 하기 위해)



#### 자바의 Executors 클래스

+ static 메서드로 다양한 형태의 스레드 풀을 제공한다.

+ ~~~java
  ExecutorService threadPool = Executors.newFixedThreadPool(10); // 10은 스레드 갯수
  threadPool.submit(task1);
  threadPool.submit(task2);
  ~~~

+ <img width="1195" alt="스크린샷 2023-04-07 13 21 06" src="https://user-images.githubusercontent.com/88477839/230540405-9f67408c-56f4-458b-bcfc-e642fb6e326a.png">

+ 위 코드에서 큐 사이즈가 Integer.MAX_VALUE 이기 때문에 큐 사이즈에 제한이 없는 걸 확인 할 수 있다.

+ 때문에 Executors.newFixedThreadPool 메서드를 사용하면 큐 사이즈 제한이 없는 스레드 풀이 생성된다는 것을 인식하고 사용해야 한다. 



#### 스레드 풀 참고 자료

+ https://velog.io/@mooh2jj/Tomcat-Thread-Pool-%EC%A0%95%EB%A6%AC
+ https://velog.io/@devel_sujin/%EB%8F%99%EC%8B%9C-%EC%9A%94%EC%B2%AD-%EB%A9%80%ED%8B%B0-%EC%93%B0%EB%A0%88%EB%93%9C



---

### block I/O와 non-block I/O

#### I/O

+ input/output, 데이터의 입출력을 의미 
+ I/O 종류
  + Network(socket)
  + file
  + Pipe (프로세스간 통신할때 사용)
  + Device - 모니터나 키보드등 디바이스에 관한 input/output



#### block I/O

+ I/O 작업을 요청한 프로세스/스레드는 요청이 완료될 때까지 블락됨을 의미



#### non-block I/O

+ 프로세스 / 스레드를 블락시키지 않고 요청에 대한 현재 상태를 즉시 리턴
+ 스레드가 블락되지 않고 즉시 리턴하기 때문에 스레드가 다른 작업을 수행할 수 있다.



#### non-block I/O 결과 처리 방식

+ non-block I/O의 이슈 - I/O 작업 완료를 어떻게 확인할 것인가?

1. 완료됐는지 반복적으로 확인
   + 완료된 시간과 완료를 확인한 시간 사이의 갭으로 인해 처리 속도가 느려질 수 있다는 단점이 있음
   + 완료됐는지 반복적으로 확인하는 것은 CPU를 낭비함 
2. I/O multiplexing(다중 입출력) 사용
   + 관심있는 I/O 작업들을 동시에 모니터링하고 그 중에 완료된 I/O 작업들을 한번에 알려줌 
   + I/O multiplexing system call을 이용하는 경우에 스레드는 블락되거나, 블락되지 않고 계속 실행될수도 있다. 
   + I/O multiplexing의 종류
     + select
     + poll
     + epoll
     + kqueue
     + IOCP(I/O completion port)
3. Callback/signal 사용
   + callback의 경우 응답이 오면 OS가 별도의 스레드를 만들고 그 스레드에서 콜백 코드를 실행하게 된다. 



#### non-block I/O의 핵심

+ Non-block I/O를 통해 I/O 요청 완료 전에도 다른일을 할 수 있다는 것이다. 
+ I/O 작업을 하고 있는 동안에 CPU가 놀고 있는것이 아니라 계속해서 다른 작업을 실행할 수 있게 함으로써 CPU를 더 잘 활용할 수 있다. 



---

###  비동기 프로그래밍

#### synchronous programming

+ 동기 프로그래밍
+ 여러 작업(task)들을 순차적으로 실행하도록 개발



#### asynchronous programming

+ 비동기 프로그래밍
+ 여러 작업들을 독립적으로 실행하도록 개발
+ asynchronous programming은 여러 작업을 동시에 실행하는 프로그래밍 방법론이다.
  + multithreading은 asynchronous programming의 한 종류이다. 
+ Asynchronous programming을 가능하게 하는 것은 multi-threads와 non-block I/O이다. 
  + 이를 잘 활용하면 스레드를 적게 쓰면서도 non-block I/O를 통해 전체 처리량을 효율적으로 늘릴 수 있다.



### I/O 관점에서의 asynchronous

+ synchronous I/O = block I/O
+ Asynchronous I/O = non-block I/O
+ synchronous I/O : 요청자가 I/O완료까지 챙겨야 할 때
+ Asynchronous I/O : I/O작업의 완료를 noti주거나 callback으로 처리



+ Asynchronous I/O :block I/O를 실행해야하는 경우 다른 thread에서 실행

