# 코딩 앙마 자바스크립트 중급 강좌 2

> 유튜버 코딩 앙마님의 자바스크립트 중급강좌를 보고 공부한 내용입니다.



## 구조 분해 할당

+ Destructuring assignment

  + 구조 분해 할당 구문은 배열이나 객체의 속성을 분해해서 그 값을 변수에 담을 수 있게 하는 표현식

+ 배열 구조 분해

  + 

    <img width="698" alt="스크린샷 2022-02-05 18 12 14" src="https://user-images.githubusercontent.com/88477839/152635808-da1fda9d-6080-4a7c-bd2a-63c32b1853c8.png">

  + <img width="1110" alt="스크린샷 2022-02-05 18 15 48" src="https://user-images.githubusercontent.com/88477839/152635865-4fad2c8b-013f-41da-ab28-49d28b7c294f.png">

  + ~~~javascript
    // split을 활용한 배열 구조 분해
    
    let str = "Mike-Tom-Jane";
    let [user1, user2, user3] = str.split('-'); // => ["Mike","Tom","Jane"]
    
    console.log(user1);// 'Mike'
    console.log(user2); // 'Tom'
    console.log(user3); // 'Jane'
    ~~~

  + ~~~javascript
    //배열 구조분해 : 기본값 설정
    
    let [a,b,c] = [1,2]; // 이 경우 c에는 undefined가 할당됨
    
    //  undefined를 방지하기 위해 아래와 같이 기본값 설정함
    let [a=3, b=4, c=5] = [1,2];
    
    console.log(a); // 1
    console.log(b); // 2
    console.log(c); // 5 = > 기본값 출력
    ~~~

  + <img width="1240" alt="스크린샷 2022-02-05 18 23 49" src="https://user-images.githubusercontent.com/88477839/152636084-64715c3a-2950-485d-86db-905f53d2da25.png">

  + ~~~javascript
    //배열 구조 분해 : 바꿔치기
    
    let a =1;
    let b =2;
    
    [a,b] = [b,a];
    ~~~

+ 객체 구조 분해

  + ~~~javascript
    let user = {name: 'Mike', age: 30};
    let {name, age} = user; 
    //let name = user.name; 과 같음
    //let age = user.age; 와 같음
    
    // 순서를 바꿔도 동일하게 작동함
    // let {age, name} = user;
    
    console.log(name); // 'Mike'
    console.log(age); // 30
    ~~~

  + 새로운 변수 이름으로 할당

    ~~~javascript
    let user = {name : 'Mike', age: 30};
    let {name: userName, age: userAge} = user;
    
    console.log(userName); // 'Mike'
    console.log(userAge); // 30
    ~~~

  + 기본값 설정하기

    ~~~javascript
    let user = {nmae:'Mike', age: 30};
    let {name, age, gender} = user; // gender에는 undefined 할당
    
    // 기본값 설정
    let {name, age, gender = 'male'} = user;
    // 만약에 객체에 gender 프로퍼티가 이미 설정되어 있다면 위같이 작성해도 'male'값이 할당 되지 않는다.
    ~~~



## 나머지 매개변수

+ arguments

  + 함수로 넘어 온 모든 인수에 접근할 수 있음

  + 함수내에서 이용 가능한 지역 변수

  + length/ index

  + array 형태의 객체임 (배열 아님)

  + 배열의 내장 메서드 없음 (forEach,map)

    ~~~javascript
    function showName(name){
      console.log(arguments.length);
      console.log(arguments[0]);
      console.log(arguments[1]);
    }
    
    showName('Mike', 'Tom');
    // 2
    // 'Mike'
    // 'Tom'
    ~~~

+ 나머지 매개변수(Rest parameters) -ES6 

  + 정해지지 않은 갯수의 인수를 배열로 나타낼 수 있게 함
  + argument와 다르게 배열의 메소드들을 활용할 수 있음

  ~~~javascript
  function showName(...names){
    console.log(names);
  }
  
  showName(); // []
  showName('Mike'); // ['Mike']
  showName('Mike', 'Tom'); // ['Mike', 'Tom']
  ~~~

  + 활용

    ~~~javascript
    function add(...numbers){
      let result = 0;
      numbers.forEach((num)=>{result += num});
      console.log(result);
    }
    
    add(1,2,3); // => 6
    add(1,2,3,4,5,6,7,8,9,10); // => 55
    ~~~

    ~~~javascript
    // 나머지 매개변수를 활용하여 생성자 함수 만들기
    
    function User(name,age,...skills){ //나머지 매개변수는 항상 마자막에 있어야 한다.
    	this.name = name;
      this.age = age;
      this.skills = skills;
    }
    
    const user1 = new User('Mike', 30, 'html', 'css');
    const user2 = new User('Tom', 20, 'JS', 'React');
    const user3 = new User('Jane', 10, 'English');
    
    console.log(user1);
    console.log(user2);
    console.log(user3);
    ~~~

    

## 전개 구문(Spread syntax)

+ 배열

  ~~~javascript
  let arr1 = [1,2,3];
  let arr2 = [4,5,6];
  
  let result = [...arr1, ...arr2];
  
  console.log(result); // [1,2,3,4,5,6]
  
  let result2 = [0, ...arr1, ...arr2, 7,8,9];
  console.log(result2);
  // => [0,1,2,3,4,5,6,7,8,9]
  ~~~

+ 객체

  ~~~javascript
  let user = {name:'Mike'}
  let Mike = {...user, age:30}
  
  console.log(mike) // {name: "Mike", age: 30}
  ~~~

+ 복제

  ~~~javascript
  let arr = [1,2,3];
  let arr2 = [...arr]; //[1,2,3]
  
  let user = {name:'Mike', age:30};
  let user2 = {...user};
  
  user2.name = "Tom";
  
  console.log(user.name); // "Mike"
  console.log(user2.name); // "Tom"
  ~~~



## 클로저

+ 자바스크립트는 어휘적 환경(Lexical Environment)를 갖는다.

+ 코드를 실행하면 스크립트내 변수들이 Lexical 환경에 올라간다. (호이스팅)

  <img width="1135" alt="스크린샷 2022-02-07 00 43 59" src="https://user-images.githubusercontent.com/88477839/152689133-625ef6f3-9737-40dd-b7a7-e4354b1eeada.png">

  + 위 코드에서 one과 num은 우선적으로 내부 Lexical 환경에서 먼저 찾는다.
  + num은 내부 Lexical환경에 있지만 one은 없기 때문에 외부 Lexcial환경으로 넓혀서 찾는다.

  <img width="1138" alt="스크린샷 2022-02-07 00 57 17" src="https://user-images.githubusercontent.com/88477839/152689358-1f8656ad-fbe6-4d51-96f3-037e02af9c5f.png">

  + 전역 Lexcial환경에서 호이스팅이 일어남.

+ Closure는 함수와 렉시컬 환경의 조합이다.

+ 함수가 생성될 당시의 외부 변수를 기억하고 생성 이후에도 계속 접근 가능하다.

  <img width="1102" alt="스크린샷 2022-02-07 01 03 12" src="https://user-images.githubusercontent.com/88477839/152689638-2e7f877b-d264-4214-a9dc-53861299b29f.png">

  ~~~javascript
  function makeCounter(){
    let num = 0; // 은닉화
    return functioin(){
      return num++;
    };
  }
  
  let counter = makeCounter();
  
  console.log(counter()); // 0
  console.log(counter()); // 1
  console.log(counter()); // 2 => 이 숫자들을 수정할수 없다. (은닉화)
  ~~~




## setTimeout / setInterval

+ setTimeout - 일정 시간이 지난 후 함수를 실행

  + ~~~javascript
    function fn(){
      console.log(3)
    }
    
    setTimeout(fn, 3000); // 3초가 지난후 fn 실행
    
    // 위와 동일
    setTimeout(function(){
      console.log(3)
    }, 3000);
    ~~~

  + ~~~javascript
    //인수가 필요한 경우 시간 뒤에 적어준다.
    
    const tId = function showName(name){
      console.log(name);
    }
    
    setTimeout(showName, 3000, 'Mike'); // Mike는 name(인수)
    
    clearTimeout(tId); // clearTimeout은 예정된 작업을 없앰 
    ~~~

    

+ setInterval - 일정 시간 간격으로 함수를 반복

  + ~~~javascript
    function showName(name){
      console.log(name);
    }
    
    const tId = setInterval(showName, 3000, 'Mike');
    
    clearInterval(tId); // => setInterval을 멈추고 싶을때
    ~~~

  + 활용

    ~~~javascript
    // 5초가 지나면 출력 멈추기
    
    let num = 0;
    
    function showTime(){
      console.log(`안녕하세요. 접속하신지 ${num++}초가 지났습니다.`);
      if(num >5){
        clearInterval(tId);
      }
    }
    
    const tId = setInterval(showTime, 1000); // 1초마다 콘솔 출력
    ~~~



## call, apply, bind

+ 함수 호출 방식과 관계없이 this를 지정할 수 있음

+ call - 모든 함수에서 사용할 수 있으며, this를 특정값으로 지정할 수 있다.

  + ~~~javascript
    const mike = {
      name:"Mike",
    };
    
    const tom = {
      name: "Tom",
    }
    
    function showThisName(){
      console.log(this.name);
    }
    
    function update(birthYear,occupation){
      this.birthYear = birthYear;
      this.occupation = occupation;
    }
    
    showThisName(); // => 아무것도 안뜸. 여기서 this는 window임
    showThisName.call(mike); // => Mike
    
    update.call(mike, 1999, "singer");
    
    consol.log(mike); // => {name:"Mike", birthYear:1999, occupation: "singer"}
    ~~~

+ apply - call과 동일하지만, 매개변수를 받을때 배열로 받는다.

  + ~~~javascript
    const mike = {
      name:"Mike",
    };
    
    const tom = {
      name: "Tom",
    }
    
    function showThisName(){
      console.log(this.name);
    }
    
    function update(birthYear,occupation){
      this.birthYear = birthYear;
      this.occupation = occupation;
    }
    
    update.apply(mike, [1999, "singer"]);
    
    consol.log(mike); // => {name:"Mike", birthYear:1999, occupation: "singer"}
    ~~~

  + 활용

    ~~~javascript
    const nums = [3,10,1,6,4];
    
    const minNum = Math.min.apply(null, nums);
    // = Math.min.apply(null, [3,10,1,6,4])
    
    const maxNum = Math.max.call(null, ...nums);
    // = Math.min.apply(null, 3, 10, 1, 6, 4)
    
    console.log(minNum); // 1
    console.log(maxNum); // 10
    ~~~

+ Bind - 함수의 this값을 영구히 바꿀 수 있다.

  + ~~~javascript
    const mike = {
    	name: "Mike",
    };
    
    function update(birtYear, occupation){
      this.birthYear = birthYear;
      this.occupation = occupation;
    }
    
    const updateMike = update.bind(mike); //this를 mike로 고정함
    
    updateMike(1980, "police");
    console.log(mike); // => {name:"Mike", birthYear: 1980, occupation:"police"}
    ~~~

  + 활용

    ~~~javascript
    const user = {
      name:"Mike",
      showName: function() {
        console.log(`hello, ${this.name}`);
      },
    };
    
    user.showName(); // hello, Mike 출력
    
    let fn = user.showName;
    
    fn.call(user); // hello, Mike 출력
    fn.apply(user); // hello, Mike 출력
    
    let boundFn = fn.bind(user);
    
    boundFn(); // hello,Mike 출력
    ~~~

    
