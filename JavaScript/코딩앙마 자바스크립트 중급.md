# 코딩 앙마 자바스크립트 중급 강좌

> 유튜버 코딩 앙마님의 자바스크립트 중급강좌를 보고 공부한 내용입니다.



## 변수

+ var

  + var는 한번 선언된 변수를 다시 선언할 수 있다.

    ~~~javascript
    var name = 'MIke';
    console.log(name); // Mike
    
    var name = 'Jane';
    console.log(name); // Jane
    ~~~

  + var는 선언하기 전에 사용할 수 있다. => 변수의 호이스팅

    ~~~javascript
    console.log(name); // undefined
    var name = 'Mike';
    ~~~

+ let

  + let은 재선언이 되지 않는다.

+ Const



## 호이스팅

+ 호이스팅은 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것 처럼 행동 하는 것이다.

+ 사실 var뿐만아니라 let과 const도 변수의 호이스팅이 발생한다.

+ 하지만 let과 const과 var 처럼 결과를 내지 않는 이유는 'Temporal Dead Zone'때문이다.

  <img width="1169" alt="스크린샷 2022-01-30 14 30 08" src="https://user-images.githubusercontent.com/88477839/151688207-af3bb5f8-8928-48f8-8ed6-e8fa7f75980d.png">

  + TDZ 영역에 있는 변수들은 사용할 수 없는데, let과 const는 TDZ의 영향을 받음
  + 할당을 하기 전에는 사용할 수 없음.

+ ~~~javascript
  // 아래코드는 문제가 없음
  
  let age = 30;
  function showAge(){
    console.log(age);
    
  }
  showAge();
  ~~~

+ ~~~javascript
  //아래코드는 문제있음
  
  let age = 30;
  function showAge(){
    console.lof(age);
    
    let age = 20;
  }
  showAge();
  
  ~~~

  + 호이스팅은 스코프 단위로 일어난다.
  + 위 코드에서 스코프는 함수 내부이다.
  + 위 함수 내부에소 호이스팅이 발생했기 때문에 코드에 에러가 생겨났다.
  + 만약 호이스팅이 발생하지 않았다면 위 코드에서 console.log(age); 는 함수 바깥에 있는 let age = 30;의 값을 출력했을 것이다. 때문에 에러가 났다는 것은 함수내부에서 호이스팅이 발생했다는 반증이다.
  + <img width="909" alt="스크린샷 2022-01-30 14 52 21" src="https://user-images.githubusercontent.com/88477839/151688393-e53949c8-206d-4b11-88d9-333c14e24e97.png">



## 변수의 생성과정

+ 1. 선언 단계
+ 2. 초기화 단계 : undefined를 할당 해주는 단계
+ 3. 할당 단계
+ var
  + Var 는 선언 및 초기화(undefined를 할당해줌)가 동시에 일어난다.
  + 그 다음 할당 단계
+  let
  + 선언 단계와 초기화 단계가 분리되어 있다. (초기화는 실제 코드에 도달했을때 이루어진다.)
    	1. 선언단계 (여기서 호이스팅이 일어남)
    	1. 초기화 단계 (초기화는 실제 코드에 도달했을 때 이루어진다.)
    	1. 할당 단계
+ Count
  + 선언 + 초기화 + 할당을 동시에 해줘야 한다.



## 스코프

+ Var - 함수 스코프(function-scoped)

  + 함수 내에서 선언된 변수만 지역변수가 된다.

  + ~~~javascript
    const age = 30;
    
    if(age>19){
      var txt = '성인';
    }
    console.log(txt); // '성인'
    
    //=> if문 블록 안에서 선언된 변수가 if문 블록 바깥에서도 사용가능함
    ~~~

    

+ Let, const - 블록 스코프(block-scoped)

  + 블록 스코프는 모든 코드블록에서 선언된 변수는 코드 블록 내에서만 유효하다.
  + 모든 코드블록이란 함수,if문, for문,while문,try/catch문 등
  + 코드 블록 내부에서 선언한 변수는 지역변수이다.



## 생성자 함수

+ 객체 리터럴

  + ~~~javascript
    let user = {
      name : 'Mike',
      age : 30,
    }
    ~~~

+ 생성자 함수

  + ~~~javascript
    // 위 객체를 여러개 만들고자 할때 생성자 함수 사용
    
    function User(name, age){ // 첫 글자는 대문자로
      this.name = name;
      this.age = age;
    }
    
    let user1 = new User('Mike', 30);
    let user2 = new User('Jane', 22);
    let user3 = new User('Tom', 17);
    
    //=> new 연산자를 사용해서 호출
    ~~~

  + <img width="911" alt="스크린샷 2022-01-30 17 35 21" src="https://user-images.githubusercontent.com/88477839/151692632-332216fe-6c7a-452a-96c8-38e5aadbf88f.png">

    

+ 생성자 함수의 동작 원리

  + ~~~javascript
    function User(name, age){
      //this={}  =>2. 빈 객체 생성 (실제로 이 코드는 작성되지 않음)
      
      this.name = name;
      this.age = age; // => 3. this에 프로퍼티들 추가
      
      //return this; => 4. this 반환 (실제로 이 코드는 작성되지 않음)
    }
    
    new 함수명(); // => 1. 함수명 실행
    ~~~

+ 메소드가 있는 생성자 함수

  + ~~~javascript
    function User(naem, age){
      this.name = name;
      this.age = age;
      this.sayName = function(){
        cocnsole.log(this.name);
      }
    }
    
    let user5 = new User('Han', 40);
    user5.sayName(); // => 'Han' 출력
    
    // 만약 new 없이
    //let user5 = User('Han', 40); 이라고 적으면 이것은 그냥 함수를 실행한 것임
    //실제 코드에는 return 코드가 명시되어 있지 않기 때문에 console.log(user5);를 하면
    // 콘솔에 undefined가 출력됨.
    ~~~

  + 

