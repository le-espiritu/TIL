# 선형 자료구조(연결 리스트&배열) -1.연결 리스트



## 1-1 연길 리스트 소개

> 순차적인 데이터나 많은 양의 데이터를 정리하는 자료 구조인 연결 리스트에 대해 살펴보자



### 연결 리스트

![mceclip3](https://user-images.githubusercontent.com/88477839/170398833-7c6915dd-25f3-4a44-a60c-3f0fd91c3e84.png)



+ 포인터를 사용하여 여러 개의 노드를 연결하는 자료 구조를 연결 리스트라고 한다.



### 노드

+ 연결 리스트의 기본 구성 요소는 **노드** 이다. 
+ 노드에는 두 가지 정보가 들어있다. 
  + 첫 번째는 **인접한 노드를 가리키는 next**라는 이름의 포인터, 
  + 두 번째는 우리가 **노드에 넣는 데이터**를 가리키는 포인터이다. (마지막 노드의 경우, 다음에 아무것도 없기 때문에 null을 가리킨다)



+ 이 리스트는 **head**라는 이름의 포인터에서 시작한다. 
+ Head는 **리스트의 첫 번째 노드**를 가리킨다.
+ **힙에서는 이 연결 리스트의 head만 알고 있**기 때문에, head.next 혹은 head.data 등으로 노드의 내용을 찾는다. 
+ 하지만 연결 리스트의 길이가 매우 길 경우, 계속 head 뒤에 next를 붙일 수는 없다. 
+ 그래서 **임시 포인터**를 사용하여 탐색하는 방법을 사용한다.



## 1-2 노드와 크기

~~~java
public class LinkedList<E> implements List<E>{
  // 노드 정의 - 내부 클래스로 정의
  class Node<E>{
    E data;
    Node<E> next; // next는 다음 node를 가르키는 포인터이기 때문에 타입이 Node임.
    public Node(E obj){ // 생성자
      data = obj;
      next = null;
    }
  }
  private Node<E> head;
  private int currentSize; // 노드 개수를 세는 변수
  
  public LinkedList(){ // 연걸리스트 기본 생성자
    head = null;
    currentSize = 0; 
  }
}
~~~

+ 위 코드는 **연결 리스트의 내부 클래스에서 노드를 정의**한 내용이다. 노드는 next라는 포인터와 data를 가진다.

+ data의 자료형은 E이다. 
+ E는 정해지지 않은 자료형이고 이렇게 구현한 연결 리스트를 사용하면 그때 지정하겠다는 의미이다. 
+ 그리고 next의 타입은 Node이다. 다른 노드를 가리키는 포인터이기 때문이다.



+ 생성자까지 추가하여 코드를 적으면 노드 객체가 완성된다. 
+ 생성자에서는 객체를 data에 저장하고 next는 우선 null로 지정한다. 
+ 이 노드 객체는 내부 클래스이기 때문에 연결 리스트가 아닌 다른 곳에서 접근할 수 없다. 
+ 외부에서 접근하기 위해 노드 객체를 만들 때와 같이 private 변수 head를 만든다.



### 노드의 개수를 세는 효율적인 방법

+ 노드의 개수를 직접 세는 방법보다 int 타입인 변수 **currentSize를 만들어 노드의 개수를 세는 방법이 더 효율적** 이다.
+ 노드의 개수를 직접 셀 경우, 요소가 n개면 n번 세야 한다. 
+ 따라서, **하나씩 세는 것의 시간 복잡도는 θ(n)**이다. 
+ 하지만 currentSize라는 변수를 만들어놓고 리스트에 요소를 추가할 때마다 currentSize의 값을 늘려 놓으면, 리스트의 크기를 바로 알 수 있다. 이럴 경우, 시간 복잡도는 정확히 **1** 이다. ( θ(1) )



## 1-3 경계 조건



### 경계 조건

+ 어떤 자료 구조든 아래의 경계 조건에서 문제가 생기진 않을지 생각해봐야 한다.
  1. 자료 구조가 비어있는 경우
  2. 자료 구조에 단 하나의 요소가 들어있을 때
  3. 자료 구조의 첫 번째 요소를 제거하거나 추가할 때
  4. 자료 구조의 마지막 요소를 제거하거나 추가할 때
  5. 자료 구조의 중간 부분을 처리할 때



## 1-4 addFirst 메소드

> 연결 리스트의 앞부분에 node를 추가하는 addFirst 메소드에 대해 살펴보자



### addFirst 메소드

+ 새로운 node를 연결 리스트의 앞부분에 추가하는 방법은 다음과 같다.
  1. 새로운 node를 만든다.
  2. 새로운 node의 next가 현재 head를 가리키도록 한다.
  3. head 포인터가 다시 새로운 노드를 가리키도록 한다.



+ 위 가정을 코드로 작성하면 다음과 같다.

  ~~~java
  public void addFirst(E obj){
    Node<E> node = new Node<E>(obj); //1
    node.next = hdad; //2
    hdad = node; // 3 이 순서를 잘 지켜야 한다. 만약 2와 3 순서를 바꾸면 가비지 컬렉션이 생겨남.
    currentSize++;
  }
  ~~~

  + 위 코드는  5가지 경계 조건에 대하여 생각하였을 때에도 문제가 없다. 
  + 그리고 새로운 요소를 추가하기 위해 뒷부분을 살펴볼 필요가 없기 때문에 시간 복잡도는 1이다.



## 1-5 addLast 메소드

> 연결 리스트의 마지막에 node를 추가하는 addLast 메소드에 대해 살펴보자



### addLast 메소드

+ addLast 메소드에서는 **연결 리스트의 마지막**을 가리키는 **임시 포인터**(tmp)를 사용한다. 

+ 연결 리스트의 요소를 확인하려면 무조건 head에서 시작해야 하는데, 연결 리스트의 마지막까지 도달하는 데 next를 너무 많이 사용해야 하기 때문이다. (head.next.next.next......)

+ 그리고 연결 리스트의 마지막 노드는 유일하게 next 포인터가 null을 가리키기 때문에, 아래 코드와 같이 addLast 메소드를 작성할 수 있다.

  ~~~java
  public void addLast(E obj){
    Node<E> tmp = head;
    while(tmp.next!=null)
      tmp=tmp.next;
    tmp.next=node;
    currentSize++;
  }
  ~~~



#### 문제 1. 경계 조건

+  head가 비어있는 경우(자료구조가 비어있는 경우)에는 tmp가 null이 되고, tmp.next를 찾지 못하는 **NullPointerException 에러가 발생** 한다. 

+ 이 문제를 해결하기 위해 리스트 맨 뒤에 추가하려 하는데 리스트가 비어있다면, **addFirst 메소드처럼 노드를 추가** 한다.이 내용을 추가한 코드는 아래와 같다.

  ~~~java
  public void addLast(E obj){
    Node<E> node = new Node<E>(obj);
    if(head==null){ // head가 비어있는 경우
      head = node;
      currentSize++;
      return; // 이 밑으로는 코드를 실행하지 않고 메소드 종료됨.
    }
    Node<E> tmp = head;
    while(tmp.next !=null)
      tmp = tmp.next;
    tmp.next=node;
    currentSize++;
  }
  ~~~



#### 문제 2 시간 복잡도

+ 연결 리스트의 마지막 노드를 찾을 때 리스트의 맨 앞부터 시작해서 마지막 요소까지 살펴보면 **시간 복잡도는  O(n)** 이다.

+ 하지만 **tail 포인터를 사용**하면 이 시간 복잡도를 **O(1) 로** 만들 수 있다. 

+ 리스트의 마지막을 가리키는 tail 포인터를 head, currentSize와 같은 전역 변수로 설정하고, 아래와 같이 tail 포인터를 추가하면 된다.

  ~~~java
  public void addLast(E obj){
    Node<E> node = new Node<E>(obj);
    if(head == null){
      head = node;
      tail = node;// head 포인터뿐만 아니라 tail 포인터도 바꿔저야 한다.
      currentSize++;
      return;
    }
    tail.next=node;
    tail = node;
    currentSize++;
  }
  ~~~

  

