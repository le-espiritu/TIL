# 자바 특성 및 알고리즘 기본 - 1.복잡성



## 1-1 자료구조의 시작



### 자료구조 종류

+ #### 연결 리스트

  ![mceclip0](https://user-images.githubusercontent.com/88477839/169696224-ec66a601-00d2-4689-851b-06961a5f479d.png)

+ #### 스택&큐

  ![mceclip1](https://user-images.githubusercontent.com/88477839/169696297-c01ff337-5995-43d1-8372-22be38251c00.png)

+ #### 체인 해시

  ![mceclip2](https://user-images.githubusercontent.com/88477839/169696322-cedb4b29-a8ec-4505-8084-4aedb21f0104.png)

+ #### 트리

  ![mceclip3](https://user-images.githubusercontent.com/88477839/169696350-0a73dc37-6f42-4517-9358-381c8851cfc4.png)

  

+ #### 정렬

  ![mceclip4](https://user-images.githubusercontent.com/88477839/169696393-8a49f2ca-f512-4b4b-8df0-231b33840be8.png)



## 1-2 복잡성 소개

> 알고리즘의 시간 복잡도와 Big-o 참고 자료 - https://blog.chulgil.me/algorithm/



### 시간 복잡도

+ 시간 복잡도는 서로 다른 알고리즘의 효율성을 비교할 때 사용한다. 시간 복잡도에는 몇 가지 규칙이 있다.



+ 규칙 1. 입력값(n)은 항상 0보다 크다.

  + input ≥ 0

  + 입력값이 음수일 수는 없다. 그래서 복잡도는 항상 0보다 크다고 가정하고 계산을 해야한다.

    

+ 규칙 2. 함수는 많은 입력값이 있을 때 더 많은 작업을 하게 된다.

  + functions do more work  for more input

  + 더 많은 입력값이 주어지면 어떤 작업을 하는 데 필요한 계산이나 처리 시간이 길어진다.

    

+ 규칙 3. 시간 복잡도에서는 모든 상수를 삭제한다.

  + drop all constants
  + 만약 어떤 알고리즘의 복잡도가 3n이라면 3은 고려하지 않고 복잡도는 n이 된다. 
  + 2n, 3n, 10n 모두 복잡도가  n인 알고리즘이다.



+ 규칙 4. 낮은 차수의 항들은 무시한다.
  + ignore lower order terms
  + 시간 복잡도에서는 *n* 과 *n^2* 를 비교할 때에는 항상 n^2 이 더 오래 걸리는 알고리즘이라고 판단한다. 
  + 여기서 의문이 들 수 있는 점은 그래프에서 (1,1)인 지점 전까지는 n이 더 오래 걸릴 수 있다는 것이다.
  + 하지만 알고리즘에서는 입력값(n)이 1보다 작은 값은 고려하지 않고 큰 값에 대해서만 생각을 하므로 n이 무한으로 커진 경우를 가정하고 비교해야 한다.
  + 이런 이유로 시간 복잡도에서는 낮은 차수의 항들을 무시한다.
  + n^3+n^2+n 이라는 함수가 있을 때, n과  n^2은 알고리즘의 시간 복잡도에 영향을 미치지 않고, 입력값이 무한이 될 때 고려해야 할 부분은 n^3이다. 



+ 규칙 5. 시간 복잡도 함수가 log 함수를 포함할 경우 밑은 무시한다.
  +  ignore the base of logs
  + 모든 로그는 서로 배수 관계이다. 
  + 그래서 복잡도에서 관해서 이야기할 때는 로그의 밑에 대해서는 고려하지 않아도 된다.
  + 로그의 밑은 무시하고 로그 ( log n)알고리즘이라고만 말하면 된다. 
  + 복잡도가 log인 알고리즘은 보통 무언가를 반으로 나누거나 2를 곱한 경우에 자주 사용된다. \
  + 그래서 만약 for 반복문을 사용해서 무언가를 탐색하면서 반으로 나누거나 2를 곱할 때 복잡도는 밑이 2인로그가 된다.
  + 10으로 나누거나 10을 곱하게 되면 밑이 10인 로그가 된다.
  + 하지만 시간 복잡도를 표시할 때에는 로그의 밑은 무시하고 그냥 log n 복잡도를 가진다고 표현한다.



+ 규칙 6. 등호를 사용하여 표현한다.

  + 2*n*=*O*(*n*) => 2*n*∈*O*(*n*) 
  + 2n 은 *O*(*n*)과 같다.
  + 여기서 *O*(*n*)은 2n 이 어떤 함수의 집합에 속한다는 의미를 가진다.
  + 그렇기 때문에 아래와 같은 등호를 활용하여 이 관계를 수학적으로 쓸 수 있다.
  
    + ***2n = O(n), 2n ∈ O(n)***
  



### log란

+ 로그라는 것은 수의 지수 값을 구하는것이다.
+ 2^3=8  / log2 8 = 3
  + 8을 나오게 만드는 2의 지수를 구하는 것



+ 로그의 조건
  + log a b
    + 밑수 a는 0보다 크며 1이 되어서 안된다.
    + 진수 b는 0보다 커야한다.
+ 로그의 성질
  1. 덧셈
     + log a b + log a c = log a (b*c)
     + 로그끼리 더할땐 진수끼리 곱하면 된다. 이때 밑수는 같아야 한다.
  2. 뺄셈
     + log a b - log a c =log a (b/c)
     + 덧셈의 반대로 생각
+ 로그 기초 출처 자료 - https://blog.naver.com/tygk1/222719318178
+ 로그 참고 자료 (좀더 상세 ) - https://palyoung.tistory.com/31



## 1-3 빅 오 표기법



### 빅 오 표기법

+ 빅 오 표기법은 알고리즘의 효율성을 표시하는 표기법이다.
+ 빅 오 표기법을 사용하면 어떤 알고리즘을 다른 알고리즘과 비교해서 표현하는 것이 가능하다.



### 시간 복잡도 그래프

![mceclip0](https://user-images.githubusercontent.com/88477839/169946291-009a21ca-ec5c-4d5a-aab1-d19af8abecb6.png)

+ 위 그래프는 복잡도가 n인 알고리즘에 빅 오 표기법을 적용한 결과이다.
+ x축은 복잡도 n, y축은 필요한 일의 양이나 메모리를 의미한다.
+ 다른 알고리즘이 이 그래프의 어떤 위치에 있는지에 따라 복잡도 n인 알고리즘과 다른 알고리즘의 복잡도를 비교할 수 있다.
+ 다른 알고리즘이 복잡도 n인 알고리즘의 아래에 있다면, 같은 일을 하는 데 시간이 덜 들기 때문에 더 빠른 알고리즘이라고 한다.
+ 반대로 복잡도 n인 알고리즘의 위에 있다면, 더 느린 알고리즘이다.
+ 빅오 표기법에서는 이러한 알고리즘 간의 관계를 다음과 같이 표현한다.
  + O(빅 오 복잡도) : 비교 대상인 그래프가 일치 혹은 아래에 있을 때 비교 대상인 다른 알고리즘과 같거나 더 빠르다.
  + θ (세타 복잡도) : 비교 대상인 그래프가 일치할 때. 비교 대상인 다른 알고리즘과 같다.
  + Ω (빅 오메가 복잡도) : 비교 대상인 그래프가 일치 혹은 위에 있을 때. 비교 대상인 다른 알고리즘과 같거나 느리다.
  + o (리틀 오 복잡도) : 비교 대상인 그래프가 아래에 있을 때. 비교 대상인 다른 알고리즘보다 더 빠르다.
  + ω (리틀 오메가 복잡도) : 비교 대상인 그래프가 위에 있을 때. 비교 대상인 다른 알고리즘과 느리다.



## 1-4 빅 오 표기법 예시



### 문제 1

+ *n*4/3 = O( n log n )

+ 풀이 : 적당히 큰 수인 1000을 n에 대입하면, 좌변은 10000이고 우변은 log의 밑이 10일 때 O(3000)이다. 그래프를 그리면 아래와 같고, 10000은 3000 이하가 아니기 때문에 이 식은 false다.

  ![mceclip0 (1)](https://user-images.githubusercontent.com/88477839/169957605-3d28fa8f-7d55-45e1-a8b2-cb6721f7a773.png)



### 문제 2

+ 3*n*^3 + 4*n*^2 + 5*n* + 6 = θ( n^3) 
+ 풀이 : 낮은 차수의 항들을 무시하면, 3n^3 = θ( n^3) 이다. 그리고 모든 상수를 삭제하면 n^3 = θ( n^3)이다. 따라서 이 식은 참이다.



### 문제 3

+  n(n-1)/2 = *O*(*n*^2)

+  풀이 : 낮은 차수의 항들을 무시하면, n^2/2 = θ( n^2 )이다. 그리고 모든 상수를 삭제하면 n^2 = θ( n^2 )이다. 따라서, 이 식은 참이다.

  

### 문제 4

+  2^n = ω(n)

+ 풀이 : 적당히 큰 수인 1000을 n에 대입하면, 좌변은 2^1000이고 우변은 ω(1000)이다. 그래프를 그리면 아래와 같고, 1000은 1000이상이기 때문에 이 식은 참이다.

  ![mceclip1](https://user-images.githubusercontent.com/88477839/169960177-8ea2ff7c-58d4-469a-84b1-411ecd06827a.png)



### 문제 5

+ n^3 = O(n^2)
+ n^2은 n^3보다 느리게 증가한다. 따라서 문제 5는 거짓이다.



### 문제 6

+ *n*2=*O*(*n*^3)
+ n^2은 n^3보다 느리게 증가한다. 따라서 문제 6은 참이다.

