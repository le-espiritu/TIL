# 해시(Hash)



## 1-1 해시 소개



### 해시

![mceclip1](https://user-images.githubusercontent.com/88477839/170809778-d1e9fc20-edbb-47cf-b190-d5611cfa6c84.png)



+ 연결 리스트의 단점은 리스트에서 무언가를 찾고 싶을 때 무조건 모든 요소를 살펴봐야 한다는 것이다. 
+ 이러한 단점을 해결하여, **데이터를 빠르게 추가하거나 제거하도록 한 데이터 구조**가 해시이다.
+ 해시는 **키, 그리고 그와 연관된 값**을 가지고 있다. 
+ 모든 요소를 살펴본 후 동일한 노드를 찾는 연결 리스트와 달리, 해시에서는 키가 주어지면 바로 그와 연관된 값을 찾을 수 있다.
+ 원하는 요소를 찾을 때, 연결 리스트의 시간복잡도는 O(n)이고(모든 요소를 다 살펴봐야하기 때문에),  해시의 시간 복잡도는 O(1)이다.



## 1-2 해시 함수



+ **Java의 Hash Code란,** 객체를 식별할 수 있는 유니크한 값을 말한다. Object의 hashCode()메소드를 통해 반환된 해시코드는 메모리에 생성된 객체의 주소를 정수로 변환한 형태를 얘기하는데, 이 정수는 중복되지 않는 고유의 값이다.



### 해시 함수

+ 해시 함수를 작성할 때 아래와 같은 점들을 고려해야 한다.

  1. 데이터의 속성
     + 예를 들어, CSSC 아이디가 있다면 CSSC 부분을 제거해야 한다.
  2. 연산이 빨라야 한다.

  3. 두 요소가 "같다면" 같은 값을 반환해야 한다.

  4. 같은 실행 환경일 경우 같은 객체라면 같은 값이 나와야 한다.

  5. 코드를 새로 실행하면 객체가 같더라도 다른 값이 나올 수 있다.
     + Object 클래스의 toString, equals, hashCode와 같은 메소드들은 오버라이딩을 하지 않으면, 기본적으로 메모리 위치를 기반으로 코드가 실행된다. 
     + 객체는 코드가 새로 실행될 때마다 메모리 상의 다른 위치에 할당되기 때문에, toString, equals, hashCode 같은 메소드들을 오버라이딩 하지 않으면, 입력으로 들어온 객체가 같더라도 다른 값(재실행되어 변경된 메모리 주소값)을 리턴하게 된다.

  6. 코드에서 최대한 충돌이 일어나지 않도록 해야 한다.




## 1-3 해시 충돌

> 해시를 만들 때 발생할 수 있는 문제점인 해시 충돌에 대해 살펴보자



### 해시 충돌

![mceclip0](/Users/helloacompany.asia/Downloads/mceclip0.png)



+ **서로 다른 값을 가진 키가 일치**하는 경우를 해시 충돌이라고 한다.
+ 예를 들어, 위 사진에서는 전화번호를 3분할한 것의 합을 키로 지정하였다.(folding 과정) 그런데 키가 2386으로 같아 해시 충돌이 발생한다.



## 1-4 해시 함수에서 문자열

> 문자열을 해시로 나타내는 방법을 살펴보자



### 해시 함수에서의 문자열

+ 문자열 "this"를 해시로 나타내려면 어떻게 해야 할까?

+ 문자는 유니코드로 변환하여 숫자 형태로 나타낼 수 있다.

  + 유니코드에서 t 는 116이다.
  + 유니코드에서 h 는 104이다.
  + 유니코드에서 i 는 105이다.
  + 유니코드에서 s 는 115이다.

  

+ 따라서 각 문자를 숫자로 변환한 후 그 숫자들을 합한다면, 문자열을 숫자로 나타낼 수 있을 것이다.

+ 그런데  이렇게 변환한 숫자들을 합할 경우, this뿐만 아니라 hits, tish 등 다른 문자열도 같은 숫자로 표현되는 **해시 충돌**이 발생한다.

+ 어떤 상수 g를 문자의 위치만큼 제곱한 뒤 그 수를 해당 문자의 숫자형태에 곱하고, 이렇게 해서 나온 자릿수들을 다 더하면 문제가 해결된다.

  + 이를 위 예제에 대입하여 공식으로 표현하면 116 + g(104 + g(105 + g(115))) 이다.
  + 위 공식을 풀어서 보면 116\*g^0 + 104\*g^1 + 105\*g^2 + 115\*g^3 이다.

  

#### 문자열을 해시로 나타내는 함수

~~~java
public int hashCode(String s){
  int g =31;
  int hash=0;
  for(int i=s.length()-1; int>=0; i--)
    hash=g*hash+s.charAt(i);
  return hash; // 나중에 배열의 인덱스로 사용하기 위해 이 정수가 필요하다.
}
~~~

+ ~~~java
  hash=g*hash+s.charAt(i);
  
  // 이 코드에 대한 부가 설명을 풀어서 하자면,  
  // 116 + g(104 + g(105 + g(115))) 에서
  
  // g*hash는 g(115), g(105+g(115)), g(104 + g(105 + g(115))) 등과 같고
  // +charAt(i)는 105+ , 105+, 104+ 등과 같다.
  ~~~



## 1-5 해시 크기 최적화

> 해시 충돌을 방지하기 위해 해시 크기를 최적화하는 방법을 살펴보자



### 해시 크기 최적화

+ **해시 충돌**을 **방지**하기 위해 해시의 크기를 최적화한다.
  + 예시 1: 해시의 크기를 홀수로 설정하여 % 연산자를 사용했을 때 나머지가 생겨 다양한 결과가 나오게 한다.
  + 예시 2: 해시의 크기를 소수로 설정하여 나머지가 다양한 숫자가 나오게 한다.



## 1-6 양수로 반환



### 양수로 변환

+ 다음과 같이 연산하면 값을 **해시(테이블)에 포함되는 양수로** 나타낼 수 있다. (Java에서는 음수를 표현하기 위해 2의 보수를 활용한다. 첫 숫자가 0이면 양수고 1이면 음수다.) 

+ 이 방법을 사용하여 data를 배열의 어느 위치에 넣을 것인지 결정한다.

~~~java
public int hashCode(String s){ // 스트링을 매개별수로 받아 정수를 반환하는 해시코드 메소드가 있다고 한다면..
	...
}


// data의 index 결정
int hashVal = data.hashCode(s); // data에서 hashCode()를 재정의했다고 가정하고 예시 코드를 작성한듯.
hashVal = hashVal & 0x7FFFFFFF;
hashVal = hashVal % tableSize;
~~~

+ 값을 양수로 변환해야 하는 이유는 배열의 인덱스는 음수가 될 수 없기 때문이다.