# 정렬(Sort)



## 1-1 정렬 소개

> 원소들을 일정한 순서로 열거하는 정렬에 대해 살펴보자



### out-of-place 정렬과 in-place 정렬

+ out-of-place정렬
  + out-of-place 정렬은 모든 데이터를 **자료 구조의 복사본에 옮긴 후** 순서대로 배열하여 정렬하는 방법이다.
  + 예를 들어 책장을 정리할때 책장의 책을 모두 바닥에 꺼내놓고 하나씩 책장에 끼워서 정리하는 방법이다.
+ In-place정렬
  +  in-place 정렬은 **자료 구조를 그대로 두고** 그 안에서 요소들의 위치를 바꾸어 정렬하는 방법이다.
  + 예를 들어 책장에서 책을 하나 꺼내고 이를 다시 다른 위치에 꽂아넣는 정리 방법이다.



### 안정 정렬과 불안정 정렬

+ 안정 정렬은 중복된 숫자가 원래 순서를 유지한 상태로 정려하는 방법이다.
  + 정렬 전에 만약에 1이라는 숫자가 2개가 있어 중복되었다면 정렬전에 1번째로 있던 1이 정렬 후에도 1번째 순서를 유지하게 된다.
+ 불안정 정렬은 중복된 숫자의 순서를 보장할 수 없다.
  + out-of-place정렬을 하게 되면 중복된 숫자의 순서를 보장할 수 없게 된다.



### 정렬 알고리즘의 시간 복잡도

+ 모든 정렬 알고리즘에 대해 **최악의 경우, 평균적인 경우, 최선의 경우의 복잡도**가 있다. 
+ 최악의 경우는 정렬 전에 큰 수에서 작은 수로 있는 경우(정렬하고자 하는 순서와 정 반대로 되어있는 경우), 최선의 경우는 이미 정렬되어 있는 경우이다. 
+ 평균적인 경우는 완전히 임의의 순서로 되어 있는 리스트를 정렬하는 경우를 의미한다.



## 1-2 선택 정렬



### 선택 정렬

![mceclip0 (4)](https://user-images.githubusercontent.com/88477839/175336422-af4b00ba-93cb-423e-bf62-0dbc6384ac8f.png)

+ 선택 정렬(select sort)은 **순서대로 리스트의 가장 작은 수를 찾고 그 수를 확정되지 않은 부분의 가장 앞 자리에 놓는 방법**이다. 
+ 리스트 안에서 순서만 바꿔주기 때문에 **in-place 정렬**이다.



+ 첫 번째 칸에서는 n-1번 대소 비교를 하고 그 이후로 n-2번, n-3번, ... , 1번 비교하기 때문에 이들을 모두 합하면, 복잡도는 O( n^2)이 된다. 
  + (n-1)+(n-2)+(n-3)+(n-4)..... = n(n-1)/2 = O(n^2)
+ 리스트가 이미 정렬되어 있다고 하더라도 대소 비교를 해야 하므로 **최선, 최악, 평균의 경우 모두 O(** n^2 **)**이 된다.

