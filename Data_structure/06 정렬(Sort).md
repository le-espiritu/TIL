# 정렬(Sort)



## 1-1 정렬 소개

> 원소들을 일정한 순서로 열거하는 정렬에 대해 살펴보자



### out-of-place 정렬과 in-place 정렬

+ out-of-place정렬
  + out-of-place 정렬은 모든 데이터를 **자료 구조의 복사본에 옮긴 후** 순서대로 배열하여 정렬하는 방법이다.
  + 예를 들어 책장을 정리할때 책장의 책을 모두 바닥에 꺼내놓고 하나씩 책장에 끼워서 정리하는 방법이다.
+ In-place정렬
  +  in-place 정렬은 **자료 구조를 그대로 두고** 그 안에서 요소들의 위치를 바꾸어 정렬하는 방법이다.
  + 예를 들어 책장에서 책을 하나 꺼내고 이를 다시 다른 위치에 꽂아넣는 정리 방법이다.



### 안정 정렬과 불안정 정렬

+ 안정 정렬은 중복된 숫자가 원래 순서를 유지한 상태로 정렬하는 방법이다.
  + 정렬 전에 만약에 1이라는 숫자가 2개가 있어 중복되었다면 정렬전에 1번째로 있던 1이 정렬 후에도 1번째 순서를 유지하게 된다.
+ 불안정 정렬은 중복된 숫자의 순서를 보장할 수 없다.
  + out-of-place정렬을 하게 되면 중복된 숫자의 순서를 보장할 수 없게 된다.



### 정렬 알고리즘의 시간 복잡도

+ 모든 정렬 알고리즘에 대해 **최악의 경우, 평균적인 경우, 최선의 경우의 복잡도**가 있다. 
+ 최악의 경우는 정렬 전에 큰 수에서 작은 수로 있는 경우(정렬하고자 하는 순서와 정 반대로 되어있는 경우), 최선의 경우는 이미 정렬되어 있는 경우이다. 
+ 평균적인 경우는 완전히 임의의 순서로 되어 있는 리스트를 정렬하는 경우를 의미한다.



## 1-2 선택 정렬



### 선택 정렬

![mceclip0 (4)](https://user-images.githubusercontent.com/88477839/175336422-af4b00ba-93cb-423e-bf62-0dbc6384ac8f.png)

+ 선택 정렬(select sort)은 **순서대로 리스트의 가장 작은 수를 찾고 그 수를 확정되지 않은 부분의 가장 앞 자리에 놓는 방법**이다. 
+ 리스트 안에서 순서만 바꿔주기 때문에 **in-place 정렬**이다.



+ 첫 번째 칸에서는 n-1번 대소 비교를 하고 그 이후로 n-2번, n-3번, ... , 1번 비교하기 때문에 이들을 모두 합하면, 복잡도는 O( n^2)이 된다. 
  + (n-1)+(n-2)+(n-3)+(n-4)..... = n(n-1)/2 = O(n^2)
+ 리스트가 이미 정렬되어 있다고 하더라도 대소 비교를 해야 하므로 **최선, 최악, 평균의 경우 모두 O(** n^2 **)**이 된다.



## 1-3 삽입 정렬



### 삽입 정렬

![mceclip0 (5)](https://user-images.githubusercontent.com/88477839/175754853-caa9c1c6-65ac-4e9b-96dd-6eddab892d4c.png)

+ 삽입 정렬(Insertion sort)은 **요소를 하나씩 꺼내서 그 요소 앞에 있는 다른 요소들과 모두 비교하는 방법**이다. 
+ 리스트 안에서 순서만 바꿔주기 때문에 **in-place 정렬**이다.



+ 최악의 경우 - 두 번째 칸에서는 1번 대소 비교를 하고 그 이후로 2번, 3번, ... , n-1번 비교하기 때문에 이들을 모두 합하면, 복잡도는 O( n^2 )이 된다. 
+ 평균적인 경우 -  복잡도는 O( n^2 )이다. 
+ 최선의 경우 - **이미 순서에 맞게 정렬**되어 있다면 각각 1번씩 n-1번 비교하면 되므로 복잡도는 **O(n)**이 된다.



+ 삽입 정렬은 잘 정렬된 딕셔너리나 데이터베이스에 정렬된 몇 개의 요소를 추가할 때 자주 사용한다. 
+ 이 경우에 복잡도는 O(n)에 가까워진다. 이미 정렬된 부분은 다시 정렬할 필요가 없기 때문이다.



## 1-4 삽입 정렬 (코드)



### 삽입 정렬을 코드로 구현하기

~~~java
for(int i =1; i<array.length; i++){ // 첫 번째 요소를 건너뛰고 두번째 요소부터 비교하기 때문에 1로 초기화함
  int j;
  int v = array[i]; // 요소를 선택하여 v에 저장
  for(int j=i-1; j>=0; j--){
    // v가 바로 전의 요소보다 크거나 같으면 break
    if(array[j]<=v)
      break;
    // v가 바로 전의 요소보다 작으면 위치를 바꿔줌
    array[j+1] = array[j];
  }
  // 선택한 요소 v는 앞에 위치하고 있는 요소들과 모든 비교가 끝난 후에야 적절한 위치에 넣어준다.
  // 하나하나 비교할때마다 넣어주는것이 아님 -> 모든 비교가 끝나고 최종 위치에 넣는 것임
  array[j+1] = v;
}
~~~

+ 위 코드에서 마지막 array[j+1] = v; 코드를 이해하기 위해서는 for문의 실행순서를 잘 이해해야함
  + for문의 증감식 ( j-- ) 을 먼저 실행하고 그 다움 조건식( j>=0 )을 평가함.
  + 그래서 조건이 j가 0보다 크거나 작다는 조건일지라도 마지막 증감식이 실행된 j의 값은 -1임.
  + -1이기 때문에 조건식에 부합하지 않고, 조건식이 false이기 때문에 코드 블럭 안의 실행 문장이 실행되지 않는 것임.



## 1-5 셀 정렬



### 셀 정렬

![mceclip0 (4)](https://user-images.githubusercontent.com/88477839/175764268-67d2f468-b28e-4353-946d-74bfaac12736.png)



+ 셀 정렬(Shell sort)은 **일정한 너비만큼 떨어진 요소를 가져와서 그 둘을 대소비교한 후 바꾸는 방법**이다. 
+ 처음에는 큰 간격으로 시작해서 더 적은 간격으로 정렬을 하고 간격의 크기가 1이 되면 삽입 정렬을 한다. 
+ 즉, 셀 정렬은 작은 값을 가진 요소는 오른쪽에서 왼쪽으로 옮기고 큰 값을 가진 요소는 왼쪽에서 오른쪽으로 옮기는 알고리즘이다.



+ 셀 정렬은 중복된 숫자의 순서가 보장되지 않는 **불안정 정렬**이다. 
+ 그리고 리스트 안에서 순서만 바꿔주기 때문에 **in-place 정렬**이다.



+ 최악의 경우, 삽입 정렬과 같아지므로 복잡도는 O( n^2 )이다. 
+ 셀 정렬의 **평균적인 시간 복잡도는 얼마의 간격을 사용했는지에 따라** 달라진다.



## 1-6 합병 정렬



### 합병 정렬

![mceclip0 (6)](https://user-images.githubusercontent.com/88477839/175768036-4d543904-c433-49ec-aa9f-565a97e70715.png)

+ 합병 정렬(Merge sort)은 **요소가 하나만 남을 때까지 리스트를 나눠준 후, 나눴던 리스트를 대소 관계에 맞게 다시 합치는 방법** 이다.
+ 합병 정렬은 중복된 숫자의 순서가 유지되는 **안정 정렬** 이다. 
+ 그리고 리스트를 나눠 다른 공간에 저장해야 하기 때문에 **out-of-place 정렬** 이다.
+ 리스트를 나눌 때마다 필요한 대소 비교의 횟수가 줄어들어 **평균적인 시간 복잡도는 O( n log n )**이 된다.



## 1-7 합병 정렬 (코드)

> 합병 정렬을 코드로 구현해보자.



### 합병 정렬 코드로 구현하기

~~~java
int[] array, temp;
public mergeSort(int[] array){ // 생성자 코드
  this.array=array;
  temp = new int[array.length]; // 빈 배열을 만들어 데이터가 정렬되면 이를 저장
  split(0,array.length-1); // 배열의 첫번째 요소의 인덱스와 마지막 요소 인덱스를 인자로 넣음
}

public void split(int low, int high){ //리스트가 1개 남을 때까지 나눈다.
  if(low == high)//배열의 첫번째 요소의 인덱스와 마지막 요소 인덱스가 같다는 뜻. 즉 리스트에 요소가 한개라는 뜻
    return;
  int mid = (high+low)/2; //리스트를 나누기 위해 중간 인덱스 값을 구함
  split(low, mid); // 리스트를 2개로 나누고 여기서 나온 첫번째 리스트를 재귀로 계속 나눔
  split(mid+1, high); // 리스트를 2개로 나누고 여기서 나온 두번째 리스트를 재귀로 계속 나눔
  merge(low, mid, high);
}

//대소 비교 후 순서에 맞게 열거한다.
public void merge(int low, int mid, int high){
  int i = low, j=mid+1, tempposn =low;
  
  // 나눈 리스트의 대소 비교와 정렬
  while( i<=mid && j<= high){
    if(array[i]<=array[j])
      temp[tempposn++] = array[i++];
    else
      temp[tempposn++]= array[j++];
  }
  // i가 mid로 가고 j가 high로 갈 때까지 반복
  while(i <= mid)
    temp[tempposn++] = array[i++];
  while(j <= high)
    temp[tempposn++] = array[j++];
  
  // 원래 배열에 다시 복사
  for (tempposn = low; tempposn <= high; tempposn++)
    array[tempposn] = temp[tempposn];
}
~~~

