# 백트래킹



### 개념

+ 모든 경우의 수를 확인해야 할때
  + for로는 확인 불가한 경우(깊이가 달라질때)
+ 말 그대로 '되추적'이다.
+ 어떤 노드의 '유망성'을 판단한 뒤, 해당 노드가 유망하지 않다면 부모 노드로 돌아가 다른 자식 노드를 찾는 방법이다.
+ 즉, 모든 경우의 수를 찾아보지만, 그 중에서도 가능성 있는 경우의 수만 찾아보는 방법이다. 
+ 백트래킹의 방법 중 하나가 DFS이다.



### 강의 영상

+ https://www.youtube.com/watch?v=atTzqxbt4DM



### 알고리즘 문제 풀이

+ 백준 15649번 N과 M(1) 문제

+ 순열 : N개의 숫장에서 M개를 뽑을때 순서가 상관있는 수열 

+ <img width="846" alt="스크린샷 2022-12-01 23 34 19" src="https://user-images.githubusercontent.com/88477839/205080128-5eed0320-b6bc-49e2-9208-e52460f4a343.png">

  

  ~~~java
  // 백준 알고리즘 15649번 문제 - 백트래킹 활용하여 풀이
  
  /*
    
  1. 아이디어
  	- 백트래킹 재귀함수 안에서 for문 돌면서 숫자 선택 (이때 방문여부 확인 )
  	- 재귀함수에서 M개를 선택할 경우 print
  
  2. 시간복잡도
  	- N! (N팩토리얼  - N * N-1 * N-2...)
  
  3. 자료구조 
  	- 결과값을 저장할 배열 - 나는 배열대신 stack을 활용함 
  	- 방문여부 체크하는 boolean []
  
  */
  
  
  //import java.util.ArrayList;
  //import java.util.List;
  
  import java.util.Scanner;
  import java.util.Stack;
  
  public class NAndM1 {
  	
  	public static int n;
  	public static int m;
  	//public static List<Integer> list=new ArrayList<>();
  	public static Stack<Integer> stack = new Stack<>();
  	public static boolean[] chk;
  	
  	public static void main(String[] args) {
  		Scanner sc = new Scanner(System.in);
  		n = sc.nextInt();
  		m = sc.nextInt();
  		
  		chk = new boolean[n+1];
  		
  		bt(0);
  		
  	}
  	
  	
  	// 트리구조를 생각하며 백트래킹을 구현한다. 
  	public static void bt(int depth) {
  		if(depth==m) { // 재귀함수는 깊이가 끝나는 시점을 명시해줘야 한다. 
  			
  			for(int j =0; j<stack.size(); j++) {
  				System.out.print(stack.get(j)+" ");
  			}
  			System.out.println();
  			return;
  		}
  		
  		for(int i=1; i<=n; i++) {
  			if(!chk[i]) {
  				chk[i]=true;
  				stack.push(i);
  				bt(depth+1);
  				
  				// 자식노드 방문이 끝나고 돌아오면 방문노드를 방문하지 않은 상태로 변경 
  				chk[i]=false;
  				stack.pop();
  			}
  		}
  	}
  
  }
  ~~~



+ 다른 분의 풀이

  + 참고 - https://st-lab.tistory.com/114

  ~~~java
  import java.io.BufferedReader;
  import java.io.InputStreamReader;
  import java.io.IOException;
  import java.util.StringTokenizer;
   
  public class Main {
   
  	public static int N;	// 정적변수로 변경
  	public static int M;	// 정적변수로 변경
  	public static int[] arr;
  	public static boolean[] visit;
  	public static StringBuilder sb = new StringBuilder();
   
  	public static void main(String[] args) throws IOException {
   
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
   
  		StringTokenizer st = new StringTokenizer(br.readLine());
   
  		// 정적변수 N과 M을 초기화해준다.
  		N = Integer.parseInt(st.nextToken());
  		M = Integer.parseInt(st.nextToken());
   
  		arr = new int[M];
  		visit = new boolean[N];
          
  		// 정적변수를 쓰면 되기 때문에 굳이 N과 M을 넘겨줄 필요 없다.
  		dfs(0);
  		System.out.println(sb);
   
  	}
   
  	public static void dfs(int depth) {
  		if (depth == M) {
  			for (int val : arr) {
  				sb.append(val).append(' ');
  			}
  			sb.append('\n');
  			return;
  		}
   
  		for (int i = 0; i < N; i++) {
  			if (!visit[i]) {
  				visit[i] = true;
  				arr[depth] = i + 1;
  				dfs(depth + 1);
  				visit[i] = false;
  			}
  		}
  	}
   
  }
  ~~~

  

### TIP

+ 백트래킹 문제는 N이 작다. (시간복잡도 때문에)
+ 재귀함수 사용할 때 종료 시점을 잊지말아야한다.