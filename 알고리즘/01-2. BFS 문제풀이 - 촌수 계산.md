# 1-2. BFS 문제 풀이

### 백준 2644번 문제 - 촌수 계산

+ <img width="921" alt="스크린샷 2022-12-30 23 51 09" src="https://user-images.githubusercontent.com/88477839/210083265-c71843d9-6ac1-4254-9003-cbb5f96ebef3.png">
  <img width="897" alt="스크린샷 2022-12-30 23 51 24" src="https://user-images.githubusercontent.com/88477839/210083269-c03901d9-f945-46f3-a829-09ef7e6baf1f.png">
  <img width="894" alt="스크린샷 2022-12-30 23 51 33" src="https://user-images.githubusercontent.com/88477839/210083275-c03b0f85-6c89-4fd9-8529-7148b7b11a93.png">



### 문제 풀이

+ 문제를 단순화 해보면, 문제에서 사람들 간의 촌수는 간선의 갯수로 구할 수 있다.

  + 나와 부모는 1개의 간선으로 이어져 있다 =>1촌
  + 나와 조부모는 2개의 간선으로 이어져 있다. =>2촌
  + 나와 부모의 형제들은 3개의 간선으로 이어져 있다. =>3촌

+ 만약의 주어진 숫자가 둘이 친척관계라면 간선의 갯수가 몇개이든간에 서로 간선으로 이어져 있을것이다.

+ 하지만 친척관계가 아니라면 간선으로 이어져 있지 않을 것이고 간선의 갯수는 0이된다.

+ 때문에 주어진 사람 수(N) 크기의 level 배열을 만든다.

  + 이 배열에는 출발지점으로 부터 해당하는 노드까지 몇개의 간선으로 이어져 있는지 저장할 수 있다.
  + 만약 출발지점으로 부터 3번까지 이어지는 간선이 없다면 level[3] = 0이 될 것이다.

+ 인접한 노드의 간선의 갯수는 현재 노드의 간선의 갯수에 +1을 하여 구할 수 있다.

  + 이렇게 구한 인접한 노드의 간선의 갯수는 level 배열에 저장한다.
  + 이는 또 그 다음 인접한 노드의 간선의 갯수를 구하는데에 사용될 것이다.

+ 코드

  ~~~java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.ArrayList;
  import java.util.LinkedList;
  import java.util.List;
  import java.util.Queue;
  import java.util.StringTokenizer;
  
  // 백준 2644번 문제 - 촌수계산하기 - BFS 알고리즘  
  
  public class P2644 {
  	public static void main(String[] args) throws NumberFormatException, IOException {
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  		int n = Integer.parseInt(br.readLine());
  		
  		int[] level = new int[n+1];
  		
  		List<Integer>[] graph = new ArrayList[n+1];
  		for(int i=0; i<graph.length; i++) {
  			graph[i] = new ArrayList<>();
  		}
  		
  		StringTokenizer st = new StringTokenizer(br.readLine());
  		int a = Integer.parseInt(st.nextToken());
  		int b = Integer.parseInt(st.nextToken());
  		
  		int m = Integer.parseInt(br.readLine());
  		for(int i=0; i<m; i++) {
  			st = new StringTokenizer(br.readLine());
  			int c = Integer.parseInt(st.nextToken());
  			int d = Integer.parseInt(st.nextToken());
  			
  			graph[c].add(d);
  			graph[d].add(c);
  		}
  		
  		//그래프 순회
  		Queue<Integer> q = new LinkedList<Integer>();
  		boolean[] chk = new boolean[n+1];
  		q.add(a);
  		
  		while(!q.isEmpty()) {
  			int now = q.poll();
  			chk[now] = true;
  			
  			if(now==b) {
  				break;
  			}
  			
  			for(int next : graph[now]) {
  				if(chk[next]==false) {
  					level[next]=level[now]+1;
  					q.add(next);
  				}
  			}
  		}
  		
  		if(level[b]==0) {
  			System.out.println(-1);
  		}else {
  			System.out.println(level[b]);
  		}
  
  	}
  
  }
  ~~~



+ 다른 분의 풀이

  ~~~java
  import java.util.LinkedList;
  import java.util.Queue;
  import java.util.Scanner;
  
  class Main {
      static int n;
      static int[][] map;
      static boolean[] isVisited;
  
      public static void main(String[] args) {
          Scanner sc = new Scanner(System.in);
          n = sc.nextInt();
          isVisited = new boolean[n + 1];
          map = new int[n + 1][n + 1];
          //촌수를 계산해야하는 서로 다른 두 사람의 번호
          int num1 = sc.nextInt();
          int num2 = sc.nextInt();
          int m = sc.nextInt(); //부모자식관계 수
          for (int i = 0; i < m; i++) {
              int x = sc.nextInt(); //부모
              int y = sc.nextInt(); //자식
              map[x][y] = 1;
              map[y][x] = 1;
          }
          bfs(num1, num2);
      }
  
      private static void bfs(int start, int end) {
          boolean isFind = false;
          Queue<Person> queue = new LinkedList<>();
          queue.offer(new Person(start, 0));
          isVisited[start] = true;
          while (!queue.isEmpty()) {
              Person person = queue.poll();
              int start2 = person.x;
              if (start2 == end) { //찾아야할 관계 찾은 경우
                  isFind = true;
                  System.out.println(person.cnt);
                  break;
              }
              for (int i = 1; i <= n; i++) { //아직 방문 안하고 관계가 있는 촌수 탐색
                  if (!isVisited[i] && map[start2][i] == 1) {
                      isVisited[i] = true;
                      queue.offer(new Person(i, person.cnt + 1));
                  }
              }
          }
          if (!isFind) System.out.println(-1); //촌수관계 X
      }
  
      private static class Person {
          int x; //번호
          int cnt; //촌수
  
          public Person(int x, int cnt) {
              this.x = x;
              this.cnt = cnt;
          }
      }
  }
  ~~~

  + 출처 - https://youngest-programming.tistory.com/455

