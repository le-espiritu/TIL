# 이진 탐색

### 문제 풀이

+ 백준 10816 숫자카드 2 문제
+ ![다운로드 (1)](https://user-images.githubusercontent.com/88477839/209172721-b1285b93-a5ae-4bba-b3c8-e0a2058b7c56.png)
+ 해당풀이 참고 - https://st-lab.tistory.com/267
+ Lower_bound 와 upper_bound를 활용하여 풀이. 



+ 성공한 코드 -재귀 함수 활용

  ~~~java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.Arrays;
  import java.util.StringTokenizer;
  
  // 백준 알고리즘 10816번 숫자 카드 문제 풀이 - 이진 탐색 활용 
  
  public class P10816 {
  	
  	public static int[] cards;
  	//public static int[] numbers;
  	//public static int[] answers;
  
  	public static void main(String[] args) throws NumberFormatException, IOException {
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  		StringTokenizer st;
  		
  		int n = Integer.parseInt(br.readLine());
  		cards = new int[n];
  		
  		st = new StringTokenizer(br.readLine());
  		for(int i=0; i<cards.length; i++) {
  			cards[i]= Integer.parseInt(st.nextToken());
  		}
  		Arrays.sort(cards); // 탐색해야 하는 숫자들 정렬  
  		
  		
  		int m = Integer.parseInt(br.readLine());
  		//numbers = new int[m];
  		//answers = new int[m];
  		
  		st=new StringTokenizer(br.readLine());
  		StringBuilder sb = new StringBuilder();
  		for(int i=0; i<m; i++) {
  			int target=Integer.parseInt(st.nextToken());
  			int count = upper_bound(0,cards.length,target)-lower_bound(0,cards.length,target);
  			
  			sb.append(count+" ");
  			
  			//answers[i]=count;
  			//System.out.print(answers[i]+" ");
  		}
  		
  		System.out.println(sb.toString());
  		
  		
  
  	}
  	
  	// 중복 원소에 대한 길이는 상한 - 하한으로 구할 수 있다. 
  	
  	// lower bound 는 하한을 의미한다.
  	// 하한은 찾고자 하는 값 이상의 값이 처음으로 나타나는 위치를 의미한다. 
  	// 왼쪽부터 볼 때 찾고자 하는값이 같거나 큰 경우를 처음 만나느 위치를 의미한다. 
  	public static int lower_bound (int start, int end, int target) {
  		if(start == end) {
  			return start;
  		}
  		
  		int mid = (start+end)/2;
  		if(target<=cards[mid]) {
  			end=mid;
  			return lower_bound(start,end, target);
  		}else {
  			start=mid+1;
  			return lower_bound(start,end,target);
  		}
  	}
  	
  	// upper bound는 상한을 의미한다.
  	// 상한은 찾고자 하는 값을 초과한 값을 처음 만나는 위치다. 
  	// 찾고자 하는 값이 더이상 넘어 갈 수 없는 위치를 의미한다. 
  	public static int upper_bound(int start, int end, int target) {
  		if(start == end) {
  			return start;
  		}
  		
  		int mid = (start+end)/2;
  		
  		if(target<cards[mid]) {
  			end=mid;
  			return upper_bound(start,end,target);
  		}else {
  			start =mid+1;
  			return upper_bound(start,end,target);
  		}
  		
  	}
  
  }
  
  
  ~~~

  

+ 성공한 코드2 - 재귀함수가 아닌 반복문 활용함

  ~~~java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.Arrays;
  import java.util.StringTokenizer;
  
  // 백준 알고리즘 10816번 숫자 카드 문제 풀이 - 이진 탐색 활용 
  
  public class P10816 {
  	
  	public static int[] cards;
  	public static int[] numbers;
  	public static int[] answers;
  
  	public static void main(String[] args) throws NumberFormatException, IOException {
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  		StringTokenizer st;
  		
  		int n = Integer.parseInt(br.readLine());
  		cards = new int[n];
  		
  		st = new StringTokenizer(br.readLine());
  		for(int i=0; i<cards.length; i++) {
  			cards[i]= Integer.parseInt(st.nextToken());
  		}
  		Arrays.sort(cards); // 탐색해야 하는 숫자들 정렬  
  		
  		
  		int m = Integer.parseInt(br.readLine());
  		//numbers = new int[m];
  		//answers = new int[m];
  		
  		st=new StringTokenizer(br.readLine());
  		StringBuilder sb = new StringBuilder();
  		for(int i=0; i<m; i++) {
  			int target=Integer.parseInt(st.nextToken());
  			int count = upper_bound(0,cards.length,target)-lower_bound(0,cards.length,target);
  			
  			sb.append(count+" ");
  			
  			//answers[i]=count;
  			
  			//System.out.print(answers[i]+" ");
  		}
  		
  		System.out.println(sb.toString());
  	
  		
  
  	}
  	
  	// 중복 원소에 대한 길이는 상한 - 하한으로 구할 수 있다. 
  	
  	// lower bound 는 하한을 의미한다.
  	// 하한은 찾고자 하는 값 이상의 값이 처음으로 나타나는 위치를 의미한다. 
  	// 왼쪽부터 볼 때 찾고자 하는값이 같거나 큰 경우를 처음 만나느 위치를 의미한다. 
  	public static int lower_bound (int start, int end, int target) {
  		
  		while(start<end) {
  			
  			int mid = (start+end)/2;
  			
  			if(target<=cards[mid]) {
  				end=mid;
  			}else {
  				start=mid+1;
  			}
  			
  		}
  		
  		return start;
  		
  	}
  	
  	// upper bound는 상한을 의미한다.
  	// 상한은 찾고자 하는 값을 초과한 값을 처음 만나는 위치다. 
  	// 찾고자 하는 값이 더이상 넘어 갈 수 없는 위치를 의미한다. 
  	public static int upper_bound(int start, int end, int target) {
  		
  		while(start<end) {
  			int mid = (start+end)/2;
  			
  			if(target<cards[mid]) {
  				end=mid;
  			}else {
  				start=mid+1;
  			}
  		}
  		
  		return start;
  		
  	}
  
  }
  ~~~

  

+ 시간 초과한 코드 - 출력할때 StringBuilder를 사용하지 않고 반복문을 사용하여 출력함

  ~~~java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.Arrays;
  import java.util.StringTokenizer;
  
  // 백준 알고리즘 10816번 숫자 카드 문제 풀이 - 이진 탐색 활용 
  
  public class P10816 {
  	
  	public static int[] cards;
  	public static int[] numbers;
  	public static int[] answers;
  
  	public static void main(String[] args) throws NumberFormatException, IOException {
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  		StringTokenizer st;
  		
  		int n = Integer.parseInt(br.readLine());
  		cards = new int[n];
  		
  		st = new StringTokenizer(br.readLine());
  		for(int i=0; i<cards.length; i++) {
  			cards[i]= Integer.parseInt(st.nextToken());
  		}
  		Arrays.sort(cards); // 탐색해야 하는 숫자들 정렬  
  		
  		
  		int m = Integer.parseInt(br.readLine());
  		numbers = new int[m];
  		answers = new int[m];
  		
  		st=new StringTokenizer(br.readLine());
  		for(int i=0; i<m; i++) {
  			numbers[i]=Integer.parseInt(st.nextToken());
  			int count = upper_bound(0,cards.length,numbers[i])-lower_bound(0,cards.length,numbers[i]);
  			answers[i]=count;
  			
  			System.out.print(answers[i]+" ");
  		}
  		
  		
  
  	}
  	
  	// 중복 원소에 대한 길이는 상한 - 하한으로 구할 수 있다. 
  	
  	// lower bound 는 하한을 의미한다.
  	// 하한은 찾고자 하는 값 이상의 값이 처음으로 나타나는 위치를 의미한다. 
  	// 왼쪽부터 볼 때 찾고자 하는값이 같거나 큰 경우를 처음 만나느 위치를 의미한다. 
  	public static int lower_bound (int start, int end, int target) {
  		if(start == end) {
  			return start;
  		}
  		
  		int mid = (start+end)/2;
  		if(target<=cards[mid]) {
  			end=mid;
  			return lower_bound(start,end, target);
  		}else {
  			start=mid+1;
  			return lower_bound(start,end,target);
  		}
  	}
  	
  	// upper bound는 상한을 의미한다.
  	// 상한은 찾고자 하는 값을 초과한 값을 처음 만나는 위치다. 
  	// 찾고자 하는 값이 더이상 넘어 갈 수 없는 위치를 의미한다. 
  	public static int upper_bound(int start, int end, int target) {
  		if(start == end) {
  			return start;
  		}
  		
  		int mid = (start+end)/2;
  		
  		if(target<cards[mid]) {
  			end=mid;
  			return upper_bound(start,end,target);
  		}else {
  			start =mid+1;
  			return upper_bound(start,end,target);
  		}
  		
  	}
  
  }
  
  ~~~





### 위 과정들과 별개로 반복문과 재귀함수 비교

+ 참고 - https://melonicedlatte.com/2021/05/10/001900.html
+ 반복문과 비교했을때 재귀함수는 속도가 느리다.
+ 재귀함수를 사용하면 지속적으로 함수를 호출하게 되는데, 이 때 사용하는 **매개변수, 지역변수, 리턴 값, 그리고 함수 종료 후 돌아가는 위치**등을 지속적으로 프로세스의 Stack에 저장해야 합니다. 
+ 이는 선언한 변수의 값만 변경해서 사용하는 반복문과 달리 많은 메모리 사용을 의미합니다.
+ 또, 함수 호출과 복귀를 하기 위한 **context switching 비용이 발생하기 때문에, 속도가 상대적으로 느립니다.** 즉, 오버헤드가 발생하여 속도가 느리게 됩니다.
  + 여기서 말하는 컨텍스트 스위칭은 재귀함수(프로세스 / 스레드) 에서 또다른 재귀함수(프로세스 /스레드)를 호출하는 그 순간, 또는 재귀함수가 종료되는 시점에서 return을 하여 그 이전에 자신을 호출했던 재귀 함수로 돌아가는 그 순간을 의미하는 듯 하다.