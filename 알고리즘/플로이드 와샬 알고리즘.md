# 플로이드

### 개념

+ 플로이드-워셜 알고리즘이라고 함.

+ **모든 노드에서 다른 모든 노드까지** 가는데 최소비용을 구하는 알고리즘 , O(V^3)
  + 다익스트라 : **하나의 노드에서 다른 모든 노드로** 가는데 드는 최소비용을 구하는 알고리즘 , O(ElogV)
+ 다이나믹 프로그래밍 기법을 사용한 알고리즘이다.
+ 인접 행렬(인접 리스트 / 2차원 배열)을 이용하여 각 노드간 최소 비용을 계산한다.
  + i번째 정점에서 j번째 정점으로 가는 비용 표현 : dist\[i\][j]
+ 다익스트라 알고리즘과 다르게 음의 간선도 사용할 수 있다.



### 작동 원리

+ 노드 j -> 노드 i 비용 배열 만들기(테이블 형태 / 2차원 배열 / 인접 행렬), 초기값 : INF
+ 간선의 값을 비용 배열에 반영
+ 모든 노드에 대해 해당 노드 거쳐서 가서 비용 작아질 경우 값 갱신



### 코드 구현 (자바)

+ ~~~java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.StringTokenizer;
  
  /*
  sample input(첫 번째 숫자는 노드의 개수, 두 번째 숫자는 간선의 개수 이다).
  5
  8
  0 1 5
  0 4 1
  0 2 7
  0 3 2
  1 2 3
  1 3 6
  2 3 10
  3 4 4
   */
  
  public class Floyd{
    static int N, M;
    static int[][] dist;
    
    public static void main(String[] args) throws NumberFormatException, IOException{
      BufferedReader br = new BufferedReader(new InputSteamReader(System.in));
      N = Integer.parseInt(br.readLine());
      M = Integer.parseInt(br.readLine());
      
      //플로이드 거리(비용) 테이블(인접행렬/2차원 배열) 초기화
      dist = new int[N][M];
      for(int i=0; i<N; i++){
        for(int j=0; j<M; j++){
          // 자기 자신으로 가는 길의 최소 비용은 0이다.
          if(i == j){
            dist[i][j] =0;
            continue;
          }
          // 자기 자신으로 가는 경우를 제외하고는 매우 큰 값(INF)으로 초기화
          dist[i][j] = 100_000_000;
        }
      }
      
      for(int i=0; i<M; i++){
        StringTokenizer st = new StringTokenizer(br.readLine());
        int a = Integer.parseInt(st.nextToken());
        int b = Integer.parseInt(st.nextToken());
        int cost = Integer.parseInt(st.nextToken());
        
        // 최소비용 갱신
        // 아래 코드 실행 후 직접적으로 이어진 정점들은 cost값을 갱신되지만,
        // 직접적으로 이어지지않은 정점들은 여전히 INF 값을 가진다.
        dist[a][b] = Math.min(dist[a][b], cost);
        dist[b][a] = Math.min(dist[b][a], cost);
      }
      
      // 플로이드 워셜 알고리즘
      // 노드(정점)를 1개부터 N개까지 거쳐가는 경우를 모두 고려한다.
      for(int k =0; k<N; k++){ // k는 중간에 경유하는 노드(정점)를 의미
        //노드 i에서 j로 가는 경우
        //k가 i나 j와 같다면 중간에 아무런 노드도 경유하지않고 직접적으로 가는 경우를 의미한다.
        for(int i=0; i<N; i++){
          for(int j=0; j<N; j++){
            //k번째 노드를 거쳐가는 비용이 기존 비용보다 더 작은 경우 갱신
            //또는 직접적으로 연결이 안되어 있던 경우(dist[i][k]=INF인경우) 연결 비용 갱신
            //dist[i][k]가 i 정점과 k 정점이 직접적으로 연결된 비용이 아닐 수 있다.
            //dist[i][k]도 이전에 다른 노드를 거쳐 합산된 비용일 수도 있다.
            //플로이드 알고리즘이 DP 알고리즘이라는것을 기억하자.
            // 아래 코드만 얼핏 봤을때는 i에서 j로 가는데 k하나만 경유하는 경우만 고려했다고 
            // 잘못 생각이 들 수도 있다. 하지만 위에서도 적어 놓았듯이, 
            // DP알고리즘에 의해 dist[i][k]도 이전에 다른 노드를 거쳐 합산된 비용일 수도 있다.
            // 따라서 i정점에서 j정점까지 도달하는데에 있어서, 중간에 0개부터 N개의 노드를 경유하는 
            // 경우를 모두 고려할 수 있다. 
            dist[i][j] = Math.min(dist[i][j], dist[i][k]+dist[k][j]);
          }
        }
      }
      
      //출력
      for(int i=0; i<N; i++){
        for(int j =0; j<N; j++){
          // 연결이 안되어 있는 경우
          if(dist[i][j] == 100_000_000){
            System.out.print("INF ");
          }else{
            System.out.print(dist[i][j]+" ");
          }
        }
        System.out.println();
      }
      
    }
    
  }
  ~~~

  + 위 코드 참고 자료 - https://sskl660.tistory.com/61